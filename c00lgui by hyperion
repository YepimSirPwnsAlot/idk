warn([[
------------------------------------------------------------------
------------------------------------------------------------------
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╣╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╣╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╣╢╢╢╢╢╣╢╢╢╢╣╢╣╢╣╢╢╢╢╢╢╢╢╢╢╣╙╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╣▓▀▓▓▓▀▓╢▓▓╙▓▓╙▓╢▓╫▓╢╢╣╢╢╣` ╙╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢▓╓▒╢▓ ▓╢╫▓▐╣▓ ▓▓╔▓╣╣╢╣╢╣`   ╙╢╢╢╣╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢▓Ç╟▓▓æ╣▓▓▓╓▓╢╫▌,╫▒╢╢╢╢╣╣░     ╙╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢@@@@╣╢╣╢@╣╢╢╢Ñ@╣╢╢╣╢╢╢░       ║╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╣▒         ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢▒           ╢╣╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╣╢╣▒            └╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╣▒╙╢╢╢╢╢╢╢╢╢╢╢╢╣▒              ╙╢╢╢╢╢╢╢╢╢╢╢╣╢╢╣╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢▒   ╙╢╢╢╢╣╢╢╣╢▒                ]╢╣╢╢╢╣╢╣╢╣╜╜ ]╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╣╣      ╙╢╢╢╢╢╢╣                ╠╢╢╢╢╢╢Ñ╜`    ╢╢╢╢╢╢╢╢ --
-- ╢╣╢╢╢╢╢╢░        ╙╢╢╢╢▒              ]╢╢╣╣╜"       ]╢╢╢╢╢╢╢╢ --
-- ╢╣╢╢╢╢╢╣▒           ╙╫╣▒            ╓╢╨╜          ,╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╣╢╣              ╢▒   ,,,,   ]╢`            ╠╢╣╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╣░             ╠▓▓██▓▓▓▓███▓▒            ,╢╢╣╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╣▒           ╓▓▓▓▓▓▓▓▓▒▓▓▓▓▓▓█▄          ║╢╢╣╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╣╢╣@╖        ▓█▓█▓▒╢╢╣╢╢╣╢╢▒▓▓▓▓▓        ]╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╣Ñ╖    ╫▓▓▓▒╢╢╣╢╣╢╣╣╢╣╢╢▒▓▓█▓      ╓╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╣╣Ñ╖,▓▓▓▓╢╢╣╢╢╢╣╣╢╣╢╣╣╣▓█▓█  ,╖@╣╣╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢▓▓▓▓╢╢╣╣╢╢╣╣╢╢╣╢╢╣▓▓▓█@╣╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢▓█▓▓▓╢╣╢╢╢╣╣╣╣╢╣╢╫█▓█▓╢╢╣╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢▓█▓█▓▒▒╢╣╢╣╣╢▒▒▓▓▓█▓╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢▒▓█▓▓█▓▓▓▓▓▓█▓▓█▓▒╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╣╢▒▓▓█▓▓▓▓▓▓▓▒╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
-- ╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢╢ --
------------------------------------------------------------------
------------------------------------------------------------------
]])

warn([[
-- Chillingo.
-- RASTERED and COMPLETELY remade by LuaViolets (DJV)/(Violjent)
-- Also a BIG thank you to Under (UnderPlayerPawel) :D
-- UnderPlayerPawel helped with remake the walking animation to be as accurate to the original one! :)
]]);

local Songa = 2194616434;

local CRE = require(script:WaitForChild("LoadLibrary"):WaitForChild("RbxUtility")).Create;

--script.CameraFollow.Disabled = false

script["Input"].Disabled = false

Players = game:GetService'Players'
Player = script

while not(Player:IsA("Player")or Players:GetPlayerFromCharacter(Player))do
	Player=Player.Parent
end

if not(Player:IsA("Player"))then
	Player = Players:GetPlayerFromCharacter(Player)
end

local Mouse,mouse,UserInputService,ContextActionService
do
	script.Parent = Player.Character
	local CAS = {Actions={}}
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInput_Event"
	Event.Parent = Player.Character
	local fakeEvent = function()
		local t = {_fakeEvent=true}
		t.Connect = function(self,f)self.Function=f end
		t.connect = t.Connect
		return t
	end
	local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
	function CAS:BindAction(name,fun,touch,...)
		CAS.Actions[name] = {Name=name,Function=fun,Keys={...}}
	end
	function CAS:UnbindAction(name)
		CAS.Actions[name] = nil
	end
	local function te(self,ev,...)
		local t = m[ev]
		if t and t._fakeEvent and t.Function then
			t.Function(...)
		end
	end
	m.TrigEvent = te
	UIS.TrigEvent = te
	Event.OnServerEvent:Connect(function(plr,io)
		if plr~=Player then return end
		if io.isMouse then
			m.Target = io.Target
			m.Hit = io.Hit
		elseif io.UserInputType == Enum.UserInputType.MouseButton1 then
			if io.UserInputState == Enum.UserInputState.Begin then
				m:TrigEvent("Button1Down")
			else
				m:TrigEvent("Button1Up")
			end
		else
			for n,t in pairs(CAS.Actions) do
				for _,k in pairs(t.Keys) do
					if k==io.KeyCode then
						t.Function(t.Name,io.UserInputState,io)
					end
				end
			end
			if io.UserInputState == Enum.UserInputState.Begin then
				m:TrigEvent("KeyDown",io.KeyCode.Name:lower())
				UIS:TrigEvent("InputBegan",io,false)
			else
				m:TrigEvent("KeyUp",io.KeyCode.Name:lower())
				UIS:TrigEvent("InputEnded",io,false)
			end
		end
	end)
	Mouse,mouse,UserInputService,ContextActionService = m,m,UIS,CAS
end

I_N = Instance.new
CF_N = CFrame.new
CF_A = CFrame.Angles
CR_3 = Color3.new
CR_F_RGB = Color3.fromRGB
C_S = ColorSequence.new
VT_3 = Vector3.new
M_R = math.rad
U_D_2 = UDim2.new
B_C = BrickColor.new
CF_FEA_XYZ = CFrame.fromEulerCF_AXYZ
M_C = math.cos
M_AC = math.acos
M_S = math.sin
M_AS = math.asin
M_ABS = math.abs
M_RAN = math.random
M_F = math.floor
M_H = math.huge

local HP_PER_SPOT = 1

local MAX_SPLATTERS = 100

local CONE_ANGLE = 120

local MAX_SPLATTER_DISTANCE = 30

local MIN_SIZE, MAX_SIZE = 0.3, 4

local LIFETIME = 5

local CONE_ANGLE = M_R(CONE_ANGLE/2)

local function Expand(obj, size)
	local start = obj.Size
	local cframe = obj.CFrame
	for i = 0, 1, 0.05 do
		wait()
		obj.Transparency = 0
		obj.Size = start:Lerp(size, i)
		obj.CFrame = cframe
	end
	wait(LIFETIME)
	for i = 0, 0.6, 0.1 do
		wait()
		obj.Transparency = obj.Transparency + .1
	end
	obj:Destroy()
end

local function GetNormal(part, pos)
	local shape
	if part:IsA("Part") then shape = part.Shape.Value
	elseif part:IsA("WedgePart") then shape = 3
	elseif part:IsA("CornerWedgePart") then shape = 4
	else shape = 5
	end
	if shape == 0 then
		return (pos-part.Position).unit, "curve", pos
	elseif shape == 1 or shape == 3 then
		local r = part.CFrame:pointToObjectSpace(pos)/part.Size
		local rot = part.CFrame-part.Position
		if r.x > 0.4999 then return rot*Vector3.new(1,0,0), "right", pos
		elseif r.x < -0.4999 then return rot*Vector3.new(-1,0,0), "left", pos
		elseif r.y > 0.4999 then return rot*Vector3.new(0,1,0), "top", pos
		elseif r.y < -0.4999 then return rot*Vector3.new(0,-1,0), "bottom", pos
		elseif r.z > 0.4999 then return rot*Vector3.new(0,0,1), "back", pos
		elseif r.z < -0.4999 then return rot*Vector3.new(0,0,-1), "front", pos
		end
		return rot*Vector3.new(0,part.Size.Z,-part.Size.Y).unit, "ramp", pos
	elseif shape == 2 then -- Cylinders
		return (pos-part.Position).unit, "curve", pos
	elseif shape == 4 then
		local r = part.CFrame:pointToObjectSpace(pos)/part.Size
		local rot = part.CFrame-part.Position
		if r.x > 0.4999 then return rot*Vector3.new(1,0,0), "right", pos
		elseif r.y < -0.4999 then return rot*Vector3.new(0,-1,0), "bottom", pos
		elseif r.z < -0.4999 then return rot*Vector3.new(0,0,-1), "front", pos
		elseif r.unit:Dot(Vector3.new(1,0,1).unit) > 0 then return rot*Vector3.new(0,part.Size.Z,part.Size.Y).unit, "lslope", pos
		end
		return rot*Vector3.new(-part.Size.Y,part.Size.X,0).unit, "rslope", pos
	else
		return Vector3.new(0,1,0), "unknown", pos
	end
end

local min, random, rad, pi, tan = math.min, math.random, math.rad, math.pi, math.tan

local Code = script;

Code:WaitForChild("Figure").Value = game:GetService("Players")[Code.Parent.Name];

local ignore = {Code.Parent}

--local C_Anim = Code.Parent["Animate"];

--C_Anim:Destroy()

local Meshes = Code:WaitForChild("Meshes"):Clone()

Code:WaitForChild("Meshes"):Destroy()

local MeshesBlood = Meshes:WaitForChild("SplatTemplate"):Clone()
Meshes.SplatTemplate:Destroy()

local SparkParticle = Code.Spark:Clone()
Code.Spark:Destroy()

local CameraScript = Code.CameraAtPart:Clone()

Code.CameraAtPart:Destroy()

if script.Parent:FindFirstChild("Humanoid") then
	for _,hs1 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs1:Stop()
	end

	for _,hs2 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs2:Stop()
	end

	for _,hs3 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs3:Stop()
	end
end

if script.Parent:FindFirstChild("Humanoid") then
	for _,hs1 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs1:Stop()
	end

	for _,hs2 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs2:Stop()
	end

	for _,hs3 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs3:Stop()
	end
end

if script.Parent:FindFirstChild("Humanoid") then
	for _,hs1 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs1:Stop()
	end

	for _,hs2 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs2:Stop()
	end

	for _,hs3 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs3:Stop()
	end
end

if script.Parent:FindFirstChild("Humanoid") then
	for _,hs1 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs1:Stop()
	end

	for _,hs2 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs2:Stop()
	end

	for _,hs3 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
		hs3:Stop()
	end
end

if Code.Parent:FindFirstChild("Animate") then
	if script.Parent:FindFirstChild("Humanoid") then
		for _,hs1 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs1:Stop()
		end

		for _,hs2 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs2:Stop()
		end

		for _,hs3 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs3:Stop()
		end
	end

	if script.Parent:FindFirstChild("Humanoid") then
		for _,hs1 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs1:Stop()
		end

		for _,hs2 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs2:Stop()
		end

		for _,hs3 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs3:Stop()
		end
	end

	script.Parent:FindFirstChild("Animate").Disabled = true;

	wait(.000001);

	script.Parent:FindFirstChild("Animate"):Destroy();
end

repeat
	wait()
until Code:WaitForChild("Figure").Value ~= nil;

if Code.Parent:FindFirstChild("Animate") then
	if script.Parent:FindFirstChild("Humanoid") then
		for _,hs1 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs1:Stop()
		end

		for _,hs2 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs2:Stop()
		end

		for _,hs3 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs3:Stop()
		end
	end

	if script.Parent:FindFirstChild("Humanoid") then
		for _,hs1 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs1:Stop()
		end

		for _,hs2 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs2:Stop()
		end

		for _,hs3 in next, script.Parent:FindFirstChild("Humanoid"):GetPlayingAnimationTracks() do
			hs3:Stop()
		end
	end

	script.Parent:FindFirstChild("Animate").Disabled = true;

	wait(.000001);

	script.Parent:FindFirstChild("Animate"):Destroy();
end

local Playa = Code:WaitForChild("Figure").Value;

local Mousa = Mouse;

local Chara = Playa.Character;

local H = Chara["Humanoid"];

local C_H = Chara["Head"];

local C_T = Chara["Torso"];

local H_R_P = Chara["HumanoidRootPart"];

local R_A = Chara["Right Arm"];

local R_L = Chara["Right Leg"];

local L_A = Chara["Left Arm"];

local L_L = Chara["Left Leg"];

local Is_Attacking = false;

local Is_Rooted = true;

local MseGuide = true;

local Anim_Type = "Idle";

local Anim_Speed = 2;

local Anim_Sine = 0;

local Anim_Change = 1;

local P_GM_Hold = false;

local P_GM_Key_Hold = false;

local IL = true;

local ToggledHeadLook = false;

local IPING = true;

local ROMD = 250;

local ROMMD = 10;

local MID = Songa;

local TP = 0;

local MV = 1.5;

local PBSA = 1.1;

local Repairing = false;

local Sprinting = false;

local Actions = {};

CameraScript.Value.Value = H;

CameraScript.Parent = Playa.PlayerGui;

CameraScript.Disabled = false;


local Effects_Folder = I_N("Folder");

Effects_Folder.Parent = Chara;
Effects_Folder.Name = "Effects_Folder";

local Music_Effect = I_N("Sound");

Music_Effect.Parent = H_R_P;
Music_Effect.Name = "Music_Effect";
Music_Effect.Looped = IL;
Music_Effect.PlaybackSpeed = PBSA;
Music_Effect.Playing = IPING;
Music_Effect.RollOffMaxDistance = ROMD;
Music_Effect.RollOffMinDistance = ROMMD;
Music_Effect.SoundId = "rbxassetid://".. MID;
Music_Effect.TimePosition = TP;
Music_Effect.Volume = MV;
Music_Effect.SoundGroup = nil;

local AHB = I_N("BindableEvent")

do
	local TF = 0;
	local LF = 0;

	local FPS = 60;
	AHB:Fire()

	game:GetService("RunService").Heartbeat:Connect(function(S, P)
		TF = TF + S
		if(TF >= 1/FPS)then
			for i = 1, M_F(TF/(1/FPS)) do
				AHB:Fire()
			end
			LF = tick()
			TF = TF - (1/FPS) * M_F(TF / (1/FPS))
		end
	end)
end

function RSW(FRS)
	if FRS then
		game:GetService("RunService").Heartbeat:wait(FRS)
	elseif not FRS then
		game:GetService("RunService").Heartbeat:wait()
	end
end

function RC(Position, Direction, Range, IgnoreDistants)
	return game.Workspace:FindPartOnRay(Ray.new(Position, Direction.unit * Range), IgnoreDistants);
end

function PA(Number)
	if Number >= 0 then
		Number = 0;
	end
	return Number;
end

function NA(Number)
	if Number <= 0 then
		Number = 0;
	end
	return Number;
end

function STT(SPart,CFr,MoveStyle2,outorin2,AnimTime)
	local MoveStyle = Enum.EasingStyle[MoveStyle2];
	local outorin = Enum.EasingDirection[outorin2];
	local tweeningInformation = TweenInfo.new(AnimTime,MoveStyle,outorin,0,false,0);
	local MoveCF = CFr;
	local TweenAnim = game:GetService("TweenService"):Create(SPart,tweeningInformation,MoveCF);
	TweenAnim:Play();
end

function CP(Parent,Name,BrickC,CastShadow,Colorr1,Colorr2,Colorr3,Material,Reflectance,Transparency,Position,Anchored,CanCollide,Locked,Massless,Shape,VT1,VT2,VT3)
	local New_Part = I_N("Part");
	New_Part.Parent = Parent;
	New_Part.Name = Name;
	New_Part.BrickColor = B_C(BrickC);
	New_Part.CastShadow = CastShadow;
	New_Part.Color = CR_F_RGB(Colorr1,Colorr2,Colorr3);
	New_Part.Material = Material;
	New_Part.Reflectance = Reflectance;
	New_Part.Transparency = Transparency;
	New_Part.CFrame = Position;
	New_Part.Anchored = Anchored;
	New_Part.CanCollide = CanCollide;
	New_Part.Locked = Locked;
	New_Part.Massless = Massless;
	New_Part.Shape = Shape;
	New_Part.Size = VT_3(VT1,VT2,VT3);
	return New_Part;
end

function CM(Parent,Name,MeshType,MeshId,TextureId,Offset,OF1,OF2,OF3,Scale1,Scale2,Scale3,VC1,VC2,VC3)
	local New_Mesh = I_N("Part");
	New_Mesh.Parent = Parent;
	New_Mesh.Name = Name;
	New_Mesh.MeshType = MeshType;
	New_Mesh.MeshId = "rbxassetid://"..MeshId;
	New_Mesh.TextureId = "rbxassetid://"..TextureId;
	New_Mesh.Offset = VT_3(OF1,OF2,OF3);
	New_Mesh.Scale = VT_3(Scale1,Scale2,Scale3);
	New_Mesh.VertexColor = VT_3(VC1,VC2,VC3);
	return New_Mesh;
end

function CW(Parent,Name,Part0,Part1,C01,C02,C11,C12)
	local New_Weld = I_N("Weld");
	New_Weld.Parent = Parent;
	New_Weld.Name = Name;
	New_Weld.Part0 = Part0;
	New_Weld.Part1 = Part1;
	if C01 ~= nil and C02 ~= nil then
		New_Weld.C0 = C01 * C02;
	end
	if C11 ~= nil and C12 ~= nil then
		New_Weld.C1 = C11 * C12;
	end
	return New_Weld;
end

function NO(Part)
	Part.TopSurface, Part.BottomSurface, Part.LeftSurface, Part.RightSurface, Part.FrontSurface, Part.BackSurface = 10, 10, 10, 10, 10, 10;
end

function CS(Parent,Name,Looped,PlaybackSpeed,Playing,RollOffMaxDistance,RollOffMinDistance,SoundId,TimePosition,Volume)
	local New_Sound;
	coroutine.resume(coroutine.create(function()
		New_Sound = I_N("Sound");
		New_Sound.Parent = Parent;
		New_Sound.Name = Name;
		New_Sound.PlaybackSpeed = PlaybackSpeed;
		New_Sound.Playing = Playing;
		New_Sound.RollOffMaxDistance = RollOffMaxDistance;
		New_Sound.RollOffMinDistance = RollOffMinDistance;
		New_Sound.SoundId = "rbxassetid://"..SoundId;
		New_Sound.TimePosition = TimePosition;
		New_Sound.Volume = Volume;
		New_Sound:Play();
		if Looped == true then
			New_Sound.Looped = true;
		else
			repeat
				wait(1);
			until New_Sound.Playing == false
			New_Sound:Destroy();
		end
	end))
	return New_Sound;
end

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function MF(Part, Type)
	if Type == "Cyl" then
		local New_Mesh = I_N("CylinderMesh", Part)
	elseif Type == "Ball" then
		local New_Mesh = I_N("SpecialMesh", Part)
		New_Mesh.MeshType = "Sphere"
	elseif Type == "Wedge" then
		local New_Mesh = I_N("SpecialMesh", Part)
		New_Mesh.MeshType = "Wedge"
	end
end

function CPR(SP, EP, TD, IW)
	local DI = CF_N(SP, EP).lookVector
	local IG = type(IW) == "table" and IW or {IW}
	return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(SP, DI * TD), IG)
end

function GR(Model, Root)
	if Root == true then
		return Model:FindFirstChild("HumanoidRootPart") or Model:FindFirstChild("Torso") or Model:FindFirstChild("UpperTorso")
	else
		return Model:FindFirstChild("Torso") or Model:FindFirstChild("UpperTorso")
	end
end

function SC(Who, data)
	coroutine.wrap(function()
		if(Code:FindFirstChild'CameraShaker')then
			local cam = Code.CameraShaker:Clone()
			cam:WaitForChild'intensity'.Value = data.Intensity or 5
			cam:WaitForChild'duration'.Value = data.Duration or 5
			cam:WaitForChild'speed'.Value = data.Speed or 10;
			if(data.Origin)then NewInstance((typeof(data.Origin) == 'Instance' and "ObjectValue" or typeof(data.Origin) == 'Vector3' and 'Vector3Value' or typeof(data.Origin)=='CFrame' and 'CFrameValue'),cam,{Name='origin',Value=data.Origin}) end
			cam:WaitForChild'rot'.Value = data.Rotation or VT_3(1,1,5)
			cam:WaitForChild'pos'.Value = data.Position or VT_3(.25,.25,.25)
			cam:WaitForChild'startdist'.Value = data.DropDist or 25;
			cam:WaitForChild'enddist'.Value = data.IneffectiveDist or 150;

			cam.Parent = Who
			wait()
			cam.Disabled = false
		end
	end)()
end

function SCA(data)
	for _,v in next, game:service'Players':players() do
		SC(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,data)
	end
end

function AD(Type, TH, TD, TDM)
	TD = TD * TDM
	if TH then
		if Type == "Flash" then
			CS(C_T,"SFX",false,M_RAN(.8,1),false,150,10,386946017,0,6.75);
		end
	end
	if TH.Health < 2000 then
		if TH.Health - TD > 0 then
			TH.Health = TH.Health - TD
		else
			if Type == "Blood" then
				BloodDeath(TH.Parent)
			elseif Type == "Flash" then	
				PunchFX(TH.Parent)
			elseif Type == "Ragdoll" then
				RagdollDeath(TH.Parent)
			end
			TH.Parent:BreakJoints()
		end
	else
		if Type == "Blood" then
			BloodDeath(TH.Parent)
		elseif Type == "Flash" then
			PunchFX(TH.Parent)
		elseif Type == "Ragdoll" then
			RagdollDeath(TH.Parent)
		end
		TH.Parent:BreakJoints()
	end
end

function FM(VEL, DEC, Who, Tors)
	return function(W,T)
		W = Who
		T = Tors
		local BV = I_N("BodyVelocity")
		W = Who
		T = Tors
		BV.P=20000
		W = Who
		T = Tors
		BV.MaxForce=VT_3(M_H,M_H,M_H)
		W = Who
		T = Tors
		BV.Velocity=VEL or VT_3(0,25,0)+(H_R_P.CFrame.lookVector*25)
		W = Who
		T = Tors
		BV.Parent=T
		W = Who
		T = Tors
		game.Debris:AddItem(BV,DEC or .5)
	end
end

function FM2(Who)
	if Who then
		if Who:FindFirstChild("Torso") then
			Who:FindFirstChild("Torso").Velocity = -H_R_P.CFrame.rightVector*75
		elseif Who:FindFirstChild("UpperTorso") then
			Who:FindFirstChild("UpperTorso").Velocity = -H_R_P.CFrame.rightVector*75
		end
	end
end

function BloodDeath(Who)
	if Who then
		local ROOT = Who:FindFirstChild("HumanoidRootPart")
		if ROOT then
			ROOT:Remove()
		end
		local MANHUM = Who:FindFirstChildOfClass("Humanoid")

		local Cloned = SparkParticle:Clone()
		Cloned.Parent = MANHUM.Parent
		Cloned.Disabled = false

		local character = Who
		local torso, MANHUM = character:WaitForChild("Torso"), character:WaitForChild("Humanoid")
		local lastHealth = MANHUM.Health
		table.insert(ignore, character)
		MANHUM.HealthChanged:connect(function(health)
			for i = 1, min(MAX_SPLATTERS, (lastHealth-health)/HP_PER_SPOT) do
				local part, pos
				local try = 1
				repeat
					local p
					repeat
						p = Vector2.new(random()*2-1, random()*2-1)
					until p.magnitude <= 1
					local r = tan(random()*CONE_ANGLE)
					local dir = Vector3.new(r*p.x, -1, r*p.y).unit
					part, pos = workspace:FindPartOnRayWithIgnoreList(Ray.new(torso.Position, dir*MAX_SPLATTER_DISTANCE), ignore)
					try = try + 1
				until part or try > 5
				if part then
					local splat = Who:Clone()
					local size = min(splat.Size.X, splat.Size.Z) * MIN_SIZE + random()*(MAX_SIZE-MIN_SIZE)
					splat.Size = Vector3.new()
					splat.CFrame = CFrame.new(pos, pos + GetNormal(part, pos)) * CFrame.Angles(-pi/2, 0, 0)
					splat.Transparency = 1
					coroutine.resume(coroutine.create(function()
						Expand(splat, Vector3.new(size, splat.Size.Y, size))
					end))
					splat.Parent = Effects_Folder
				end
			end
			lastHealth = health
		end)

		if MANHUM then
			MANHUM.BreakJointsOnDeath = false
			MANHUM.Health = 0
		end

		if Who:FindFirstChild("R6Ragdoll") == nil and Who:FindFirstChild("R15Ragdoll") == nil then
			if Who:FindFirstChild("UpperTorso") then
				local SCRIPT = script.R15Ragdoll:Clone()
				SCRIPT.Parent = Who
				SCRIPT.Disabled = false
			else
				local SCRIPT = script.R6Ragdoll:Clone()
				SCRIPT.Parent = Who
				SCRIPT.Disabled = false
			end
			local TORSO = Who:FindFirstChild("Torso") or Who:FindFirstChild("UpperTorso")
		end
		Who:BreakJoints()
		if Who:FindFirstChild("Slaughtered") == nil then
			local MARK = I_N("Folder",Who)
			MARK.Name = "Slaughtered"
		else
			if Who:FindFirstChild("Slaughtered") then
				local TORSO = Who:FindFirstChild("Torso") or Who:FindFirstChild("UpperTorso")
				if TORSO then
					TORSO.RotVelocity = VT_3(0,math.random(-25,25),0)
				end
			end
		end
		coroutine.resume(coroutine.create(function()
			wait(.5)
		end))
	end
end

function RagdollDeath(Who)
	if Who then
		local ROOT = Who:FindFirstChild("HumanoidRootPart")
		if ROOT then
			ROOT:Remove()
		end

		local MANHUM = Who:FindFirstChildOfClass("Humanoid")

		if MANHUM then
			MANHUM.BreakJointsOnDeath = false
			MANHUM.Health = 0
		end

		if Who:FindFirstChild("R6Ragdoll") == nil and Who:FindFirstChild("R15Ragdoll") == nil then
			if Who:FindFirstChild("UpperTorso") then
				local SCRIPT = script.R15:Clone()
				SCRIPT.Parent = Who
				SCRIPT.Disabled = false
			else
				local SCRIPT = script.R6:Clone()
				SCRIPT.Parent = Who
				SCRIPT.Disabled = false
			end
			local TORSO = Who:FindFirstChild("Torso") or Who:FindFirstChild("UpperTorso")
		end
		Who:BreakJoints()
		if Who:FindFirstChild("Slaughtered") == nil then
			local MARK = I_N("Folder",Who)
			MARK.Name = "Slaughtered"
		else
			if Who:FindFirstChild("Slaughtered") then
				local TORSO = Who:FindFirstChild("Torso") or Who:FindFirstChild("UpperTorso")
				if TORSO then
					TORSO.RotVelocity = VT_3(0,math.random(-25,25),0)
				end
			end
		end
		coroutine.resume(coroutine.create(function()
			-- saz.
		end))
	end
end

function PunchFX(Who)
	if Who then
		local ROOT = Who:FindFirstChild("HumanoidRootPart")

		local b = Instance.new("Part",Effects_Folder)
		b.Anchored = true
		b.CanCollide = true
		b.Size = Vector3.new(1,1,1)
		b.CFrame = ROOT.CFrame or Who:FindFirstChild("HumanoidRootPart").CFrame
		b.BrickColor = BrickColor.new("White")
		b.Material = "Neon"
		b.Reflectance = 1

		local l = Instance.new("PointLight",b)
		l.Color = b.BrickColor.Color
		l.Brightness = 1
		l.Range = 0

		local bm = Instance.new("SpecialMesh",b)
		bm.Scale = Vector3.new(0,0,0)
		bm.MeshType = "Sphere"

		coroutine.wrap(function()
			for i=0,1,.1 do
				bm.Scale = Vector3.new(7.5*i,7.5*i,7.5*i)
				b.Transparency = i
				l.Range = 25*i
				l.Brightness = 1-1*i

				RSW()
			end

			b:Destroy()
		end)()
		for a=1,3 do
			local b = Instance.new("Part",Effects_Folder)
			b.Anchored = true
			b.CanCollide = true
			b.Size = Vector3.new(1,1,1)
			b.CFrame = ROOT.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			b.BrickColor = BrickColor.new("White")
			b.Material = "Neon"

			local bm = Instance.new("SpecialMesh",b)
			bm.Scale = Vector3.new(0,0,0)
			bm.MeshType = "Sphere"

			coroutine.wrap(function()
				for i=0,1,.1 do
					bm.Scale = Vector3.new(1.5*i,27.5*i,1.5*i)
					b.Transparency = i

					RSW()
				end

				b:Destroy()
			end)()
		end

		wait(.000001);

		if ROOT then
			ROOT.Anchored = true;
		end

		local Hum = Who:FindFirstChildOfClass("Humanoid")

		Hum.BreakJointsOnDeath = false;

		Hum.Health = -893485748934857489485748948754893487548398476738476834767;

		coroutine.resume(coroutine.create(function()
			-- saz.
		end))
	end
end

function AA(Type, Position, Range, MinimumDamage, MaximumDamage, DoesFling, DoesInstantKill)
	for index, CD in pairs(game.Workspace:GetDescendants()) do
		if CD.ClassName == "Model" and CD ~= Chara then
			local MH = CD:FindFirstChildOfClass("Humanoid")
			if MH then
				local MT = CD:FindFirstChild("Torso") or CD:FindFirstChild("UpperTorso")
				if MT and Range >= (MT.Position - Position).Magnitude then
					if DoesInstantKill == true then
						if Type == "Blood" then
							BloodDeath(CD)
						elseif Type == "Flash" then
							PunchFX(CD)
						elseif Type == "Ragdoll" then
							RagdollDeath(CD)

							if DoesFling == 1 then
								MT.Velocity = Vector3.new( math.random(-50,50),math.random(-150,225),math.random(-50,50));
								MT.RotVelocity = Vector3.new(math.random(-45,45),math.random(-45,45),math.random(-45,45));
							elseif DoesFling == 2 then
								MT.Velocity = Vector3.new( math.random(-4,4),math.random(-4,6),math.random(-4,4));
								MT.RotVelocity = Vector3.new(math.random(-45,45),math.random(-45,45),math.random(-45,45));
							end
						end
					else
						if Type ~= "Flash" then
							MH.BreakJointsOnDeath = false
							local Damage = M_RAN(MinimumDamage, MaximumDamage)
							AD(Type, MH, Damage, MaximumDamage)
						elseif Type == "Flash" then
							MH.BreakJointsOnDeath = false
							local Damage = M_RAN(MinimumDamage, MaximumDamage)
							AD(Type, MH, Damage, MaximumDamage)

							local ROOT = MH.Parent:FindFirstChild("HumanoidRootPart")

							local b = Instance.new("Part",Effects_Folder)
							b.Anchored = true
							b.CanCollide = true
							b.Size = Vector3.new(1,1,1)
							b.CFrame = ROOT.CFrame or CD:FindFirstChild("HumanoidRootPart").CFrame
							b.BrickColor = BrickColor.new("White")
							b.Material = "Neon"
							b.Reflectance = 1

							local l = Instance.new("PointLight",b)
							l.Color = b.BrickColor.Color
							l.Brightness = 1
							l.Range = 0

							local bm = Instance.new("SpecialMesh",b)
							bm.Scale = Vector3.new(0,0,0)
							bm.MeshType = "Sphere"

							coroutine.wrap(function()
								for i=0,1,.1 do
									bm.Scale = Vector3.new(7.5*i,7.5*i,7.5*i)
									b.Transparency = i
									l.Range = 25*i
									l.Brightness = 1-1*i

									RSW()
								end

								b:Destroy()
							end)()

							for a=1,3 do
								local b = Instance.new("Part",Effects_Folder)
								b.Anchored = true
								b.CanCollide = true
								b.Size = Vector3.new(1,1,1)
								b.CFrame = ROOT.CFrame
								b.BrickColor = BrickColor.new("White")
								b.Material = "Neon"

								local bm = Instance.new("SpecialMesh",b)
								bm.Scale = Vector3.new(0,0,0)
								bm.MeshType = "Sphere"

								b.CFrame = b.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))

								coroutine.wrap(function()
									for i=0,1,.1 do
										bm.Scale = Vector3.new(1.5*i,27.5*i,1.5*i)
										b.Transparency = i

										RSW()
									end

									b:Destroy()
								end)()
							end
						end

						if DoesFling == 1 then
							MT.Velocity = Vector3.new( math.random(-50,50),math.random(-150,225),math.random(-50,50));
							MT.RotVelocity = Vector3.new(math.random(-45,45),math.random(-45,45),math.random(-45,45));
						elseif DoesFling == 2 then
							MT.Velocity = Vector3.new( math.random(-4,4),math.random(-4,6),math.random(-4,4));
							MT.RotVelocity = Vector3.new(math.random(-45,45),math.random(-45,45),math.random(-45,45));
						end
					end
				end
			end
		end
	end
end

function AFunction(Position, Range)
	for index, CD in pairs(game.Workspace:GetDescendants()) do
		if CD.ClassName == "Model" and CD ~= Chara then
			local MH = CD:FindFirstChildOfClass("Humanoid")
			if MH then
				local MT = CD:FindFirstChild("Torso") or CD:FindFirstChild("UpperTorso")
				if MT and Range >= (MT.Position - Position).Magnitude then
					if DoesInstantKill == true then
						if Type == "Blood" then
							BloodDeath(CD)
						elseif Type == "Flash" then
							PunchFX(CD)
						elseif Type == "Ragdoll" then
							RagdollDeath(CD)

							if DoesFling == 1 then
								MT.Velocity = Vector3.new( math.random(-50,50),math.random(-150,225),math.random(-50,50));
								MT.RotVelocity = Vector3.new(math.random(-45,45),math.random(-45,45),math.random(-45,45));
							elseif DoesFling == 2 then
								MT.Velocity = Vector3.new( math.random(-4,4),math.random(-4,6),math.random(-4,4));
								MT.RotVelocity = Vector3.new(math.random(-45,45),math.random(-45,45),math.random(-45,45));
							end
						end
					else
						if Type ~= "Flash" then
							MH.BreakJointsOnDeath = false
							local Damage = M_RAN(MinimumDamage, MaximumDamage)
							AD(Type, MH, Damage, MaximumDamage)
						end

						if DoesFling == 1 then
							MT.Velocity = Vector3.new( math.random(-50,50),math.random(-150,225),math.random(-50,50));
							MT.RotVelocity = Vector3.new(math.random(-45,45),math.random(-45,45),math.random(-45,45));
						elseif DoesFling == 2 then
							MT.Velocity = Vector3.new( math.random(-4,4),math.random(-4,6),math.random(-4,4));
							MT.RotVelocity = Vector3.new(math.random(-45,45),math.random(-45,45),math.random(-45,45));
						end
					end
				end
			end
		end
	end
end

function CPR2(startPos,endPos,range,ignoreList)
	local ray = Ray.new(startPos,(endPos-startPos).unit*range)
	local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Chara},false,true)
	return part,pos,norm,(pos and (startPos-pos).magnitude)
end

function NE(TE)
	local NET = TE.ET or "Block"
	local NES = TE.ES or VT_3(1,1,1)
	local NEES = TE.EES or VT_3(0,0,0)
	local NEST = TE.EST or 0
	local NEET = TE.EET or 1
	local NECF = TE.ECF or H_R_P.CFrame
	local NEMD = TE.EMD or nil
	local NER1 = TE.ER1 or 0
	local NER2 = TE.ER2 or 0
	local NER3 = TE.ER3 or 0
	local NEM = TE.EM or "Plastic"
	local NEC = TE.EC or CR_F_RGB(1,1,1)
	local NETI = TE.ETI or 45
	local NESID = TE.ESID or nil
	local NESP = TE.ESP or nil
	local NESV = TE.ESV or nil
	local NEUBRM = TE.EUBRM or false
	local NEBR = TE.EBR or 0
	local NESBR = TE.ESBR or 0
	coroutine.resume(coroutine.create(function()
		local PTS = false
		local SD
		local NE = Meshes[NET]:Clone()
		NE.Parent = Effects_Folder
		NE.Name = "New_Effect_"..NET
		NE.Size = NES
		NE.Transparency = NEST
		NE.Material = NEM
		NE.Color = NEC
		NE.Anchored = true
		NE.CanCollide = false
		NE.Locked = true
		if NESID ~= nil and NESP ~= nil and NESV ~= nil then
			PTS = true
			SD = CS(NE,"New_Sound",false,NESP,false,1000,950,NESID,0,NESV)
		end
		if NE ~= nil then
			local BR1 = 1 + NEBR / 50
			local BR2 = 1 + NESBR / 50
			local MS
			if NEMD ~= nil then
				if NEUBRM == true then
					MS = NECF.p - NEMD.Magnitude / NETI * BR1
				else
					MS = NECF.p - NEMD.Magnitude / NETI
				end
			end
			local NEG
			if NEUBRM == true then
				NEG = (NES - NEES) * (BR2 + 1)
			else
				NEG = NES - NEES
			end
			local NE_T = NEST - NEET
			if NET == "Block" then
				NE.CFrame = NECF * CF_A(M_R(M_RAN(0, 360)), M_R(M_RAN(0, 360)), M_R(M_RAN(0, 360)))
			else
				NE.CFrame = NECF
			end
			if NEUBRM == true then
				for NELOP = 1, NETI + 1 do
					RSW()
					NE.Size = NE.Size - VT_3(NEG.X * (1 - NELOP / NETI * BR2), NEG.Y * (1 - NELOP / NETI * BR2), NEG.Z * (1 - NELOP / NETI * BR2)) * BR2 / NETI
					NE.Transparency = NE.Transparency - NE_T / NETI
					if NET == "Block" then
						NE.CFrame = NECF * CF_A(M_R(M_RAN(0, 360)), M_R(M_RAN(0, 360)), M_R(M_RAN(0, 360)))
					else
						NE.CFrame = NE.CFrame * CF_A(M_R(NER1), M_R(NER2), M_R(NER3))
					end
					if NEMD ~= nil then
						local NEOR = NE.Orientation
						NE.CFrame = CF_N(NE.Position, NEMD) * CF_N(0, 0, -MS * (1 - NELOP / NETI * BR1))
						NE.CFrame = CF_N(NE.Position) * CF_A(M_R(NEOR.X), M_R(NEOR.Y), M_R(NEOR.Z))
					end
				end
			else
				for NELOP = 1, NETI + 1 do
					RSW()
					NE.Size = NE.Size - NEG / NETI
					NE.Transparency = NE.Transparency - NE_T / NETI
					if NET == "Block" then
						NE.CFrame = NECF * CF_A(M_R(M_RAN(0, 360)), M_R(M_RAN(0, 360)), M_R(M_RAN(0, 360)))
					else
						NE.CFrame = NE.CFrame * CF_A(M_R(NER1), M_R(NER2), M_R(NER3))
					end
					if NEMD ~= nil then
						local NEOR = NE.Orientation
						NE.CFrame = CF_N(NE.Position, NEMD) * CF_N(0, 0, -MS)
						NE.CFrame = CF_N(NE.Position) * CF_A(M_R(NEOR.X), M_R(NEOR.Y), M_R(NEOR.Z))
					end
				end
			end
			NE.Transparency = 1
			if PTS == false then
				NE:Destroy()
			else
				repeat
					RSW()
				until NE:FindFirstChildOfClass("Sound") == nil
				NE:Destroy()
			end
		elseif PTS == false then
			NE:Destroy()
		else
			repeat
				RSW()
			until NE:FindFirstChildOfClass("Sound") == nil
			NE:Destroy()()
		end
	end))
end

Is_Rooted = false

function Joint(name,part0,part1,c0,c1,type) -- Credits to Nebula_Zoroark because this is one of his functions i used!
	local joint = I_N(type or "Motor6D");
	joint.Part0 = part0;
	joint.Part1 = part1;
	joint.C0 = c0 or CF_N();
	joint.C1 = c1 or CF_N();
	joint.Parent=part0;
	joint.Name=name or part0.." to "..part1.." "..joint.ClassName;
	return joint;
end

function Animate(joint,c0,alpha,style,dir) -- Credits to Nebula_Zoroark because this is one of his functions i used!
	if(style=='Lerp')then
		joint.C0 = joint.C0:lerp(c0,alpha);
	else
		local info = TweenInfo.new(alpha or 1,style or Enum.EasingStyle.Linear,dir or Enum.EasingDirection.Out,0,false,0);
		local tween = game.TweenService:Create(joint,info,{C0=c0});
		tween:Play();
		return tween;
	end
end

local T_R = Joint("RootJoint",H_R_P,C_T,CF_N(),CF_N());

local H_N = Joint("Neck",C_T,C_H,CF_N(0,1.5,0),CF_N());

local L_S = Joint("Left Shoulder",C_T,L_A,CF_N(-1.5,.5,0),CF_N(0,.5,0));

local R_S = Joint("Right Shoulder",C_T,R_A,CF_N(1.5,.5,0),CF_N(0,.5,0));

local L_H = Joint("Left Hip",C_T,L_L,CF_N(-.5,-2,0),CF_N(0,0,0));

local R_H = Joint("Right Hip",C_T,R_L,CF_N(.5,-2,0),CF_N(0,0,0));

local L_SC0 = L_S.C0

local R_SC0 = R_S.C0

local H_NC0 = H_N.C0

local L_HC0 = L_H.C0

local R_HC0 = R_H.C0

local T_RC0 = T_R.C0

function Animator(Type,DA1,DA2)
	local R_A_TI = DA1.AD1

	local L_A_TI = DA1.AD2

	local L_L_TI = DA1.AD4

	local R_L_TI = DA1.AD3

	local C_H_TI = DA1.AD5

	local C_T_TI = DA1.AD6

	local R_A_CF_N = DA1.R_A

	local L_A_CF_N = DA1.L_A

	local L_L_CF_N = DA1.L_L

	local R_L_CF_N = DA1.R_L

	local C_H_CF_N = DA1.C_H

	local C_T_CF_N = DA1.C_T

	Animate(T_R,C_T_CF_N,C_T_TI,Type)

	Animate(R_S,R_A_CF_N,R_A_TI,Type)

	Animate(L_S,L_A_CF_N,L_A_TI,Type)

	Animate(R_H,R_L_CF_N,R_L_TI,Type)

	Animate(L_H,L_L_CF_N,L_L_TI,Type)

	Animate(H_N,C_H_CF_N,C_H_TI,Type)
end

function TO(position)
	H_R_P.CFrame=CFrame.new(H_R_P.CFrame.p,Vector3.new(position.X,H_R_P.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

function CP2(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = I_N("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.Color = BRICKCOLOR
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = C_T.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

function SP(FROM,TO,BIG)
	local TRAIL = CP2(3, game:GetService("Workspace"), "Neon", 0, 0, CR_F_RGB(255, 102, 204), "Trail", VT_3(1,1,1))           
	MF(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT_3(.25,DIST,.25)
	else
		TRAIL.Size = VT_3(.25,DIST,.25)
	end
	TRAIL.CFrame = CF_N(FROM, TO) * CF_N(0, 0, -DIST/2) * CF_A(M_R(90),M_R(0),M_R(0))
	local Numb1 = 55
	local Numb2 = 2
	coroutine.resume(coroutine.create(function()
		for i = 1, Numb1/Numb2 do
			RSW()
			TRAIL.Transparency = TRAIL.Transparency + 0.03
		end
		TRAIL:remove()
	end))
end

local Sppedd = 16;

-- AA("Ragdoll",H_R_P.Position,7.5,1,3,0,false);

--CS(Part,"SFX",false,1,false,125,10,5961220,0,7.5)
--CS(Part,"SFX",false,1,false,150,10,1843194183,0,5)

--STT(Sword,{Transparency = 1},"Quad","Out",1)

--game:GetService("Debris"):AddItem(Sword, 1);

local Combo = 1

local Comboing = false;

local Attacking_NASP = .1;

local PoseInTime = 1;

local PartOfYes = nil;

function Actions.Attack_Template()
	Is_Attacking = true;
	Is_Rooted = true;

	Is_Rooted = false;
	Is_Attacking = false;
end

function Actions.Combos(ComboLOL)
	if ComboLOL then
		if ComboLOL == 1 then
			Is_Attacking = true;
			Is_Rooted = false;

			Attacking_NASP = .15;

			Animate(T_R,CF_N(-0.1, -0.3, 0.6)*CF_A(M_R(42.9), M_R(-14),M_R(7.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_S,CF_N(-1.63, 0.42, -0.14)*CF_A(M_R(80.8), M_R(1),M_R(2.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(R_S,CF_N(1.48, 0.41, -0.15)*CF_A(M_R(-34.7), M_R(-1.9),M_R(6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_H,CF_N(-0.4, -1.87, 0.4)*CF_A(M_R(-49.6), M_R(9.8),M_R(6.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(H_N,CF_N(-0.03, 1.5, -0.14)*CF_A(M_R(-27.4), M_R(12.3),M_R(18.4)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_H,CF_N(0.68, -1.53, 0.73)*CF_A(M_R(-61.4), M_R(-7.4),M_R(7.9)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 

			wait(.325);

			Attacking_NASP = .1;

			Animate(T_R,CF_N(-0.1, -0.3, -0.1)*CF_A(M_R(-49.8), M_R(-3.6),M_R(-2.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_S,CF_N(-1.13, 1.14, -0.76)*CF_A(M_R(121.3), M_R(-23.4),M_R(32.1)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_S,CF_N(1.48, 0.41, -0.15)*CF_A(M_R(-34.7), M_R(-1.9),M_R(6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_H,CF_N(-0.54, -1.23, -1.29)*CF_A(M_R(57.2), M_R(10.5),M_R(-4)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(H_N,CF_N(-0.12, 1.54, 0.12)*CF_A(M_R(19.7), M_R(6.9),M_R(-0.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_H,CF_N(0.63, -1.94, -0.38)*CF_A(M_R(-1.8), M_R(-3.3),M_R(6.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);

			wait(.175);

			CS(L_A,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,5.5);

			AA("Flash",L_A.Position,8.25,3,5,0,false);

			Is_Rooted = false;
			Is_Attacking = false;
		elseif ComboLOL == 2 then
			Is_Attacking = true;
			Is_Rooted = false;

			Attacking_NASP = .15;

			Animate(T_R,CF_N(-0.1, -0.3, 0.6)*CF_A(M_R(44.6), M_R(14.9),M_R(-12.9)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(L_S,CF_N(-1.55, 0.37, -0.39)*CF_A(M_R(-23.6), M_R(-27.9),M_R(-9.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_S,CF_N(1.53, 0.46, 0.02)*CF_A(M_R(73.4), M_R(26.6),M_R(23)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(L_H,CF_N(-0.5, -1.97, 0.44)*CF_A(M_R(-44.5), M_R(10.5),M_R(-2.9)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(H_N,CF_N(0.06, 1.52, -0.11)*CF_A(M_R(-32.5), M_R(-8.6),M_R(-15)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_H,CF_N(0.49, -1.65, 0.74)*CF_A(M_R(-60.6), M_R(-9.1),M_R(-3)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);

			wait(.325);

			Attacking_NASP = .1;

			Animate(T_R,CF_N(-0.1, -0.3, -0.1)*CF_A(M_R(-49.8), M_R(-3.6),M_R(-2.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(L_S,CF_N(-1.54, 0.25, 0.03)*CF_A(M_R(-35), M_R(-2.4),M_R(1.1)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(R_S,CF_N(0.99, 1.07, -0.86)*CF_A(M_R(126.2), M_R(5.5),M_R(-36.5)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_H,CF_N(-0.54, -1.23, -1.29)*CF_A(M_R(57.2), M_R(10.5),M_R(-4)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(H_N,CF_N(-0.12, 1.54, 0.12)*CF_A(M_R(19.7), M_R(6.9),M_R(-0.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(R_H,CF_N(0.63, -1.94, -0.38)*CF_A(M_R(-1.8), M_R(-3.3),M_R(6.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);

			wait(.175);

			CS(R_A,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,5.5);

			AA("Flash",R_A.Position,8.25,3,5,0,false);

			Is_Rooted = false;
			Is_Attacking = false;
		end
	end
end

function Actions.Teleport()
	if Mousa then
		local Target_Pos = Mousa.Hit;

		if Target_Pos then
			Is_Attacking = true;
			Is_Rooted = true;

			Attacking_NASP = .25;

			Animate(T_R,CF_N(0, 1.65, 0)*CF_A(M_R(18), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(L_S,CF_N(-1.24, 0.45, 0.45)*CF_A(M_R(65.2), M_R(29.3),M_R(-76.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(R_S,CF_N(1.1, 0.45, 0.45)*CF_A(M_R(65.2), M_R(-29.3),M_R(76.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(L_H,CF_N(-0.65, -2.03, 0.2)*CF_A(M_R(-12.1), M_R(-1.2),M_R(-11.9)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(H_N,CF_N(0, 1.49, 0.15)*CF_A(M_R(18), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(R_H,CF_N(0.66, -2.03, 0.2)*CF_A(M_R(-12.1), M_R(1.2),M_R(11.9)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

			wait(.1);

			H_R_P.CFrame = CF_N(Target_Pos.Position) * CF_N(0, 3, 0);

			CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,6.25);

			SCA({
				Intensity=2.5,
				Duration=.000000001, 
				Origin=H_R_P.Position, 
				DropDist=1725, 
				IneffectiveDist=1950
			});

			local R1 = math.random(-5,5);

			local R2 = math.random(-5,5);

			local R3 = math.random(-5,5);

			local Chill_Sphere = Meshes.Chill_Sphere2:Clone();

			Chill_Sphere.Parent = Effects_Folder;

			Chill_Sphere.Size = VT_3(5,5,5);

			Chill_Sphere.Transparency = .2;

			Chill_Sphere.Anchored = true;

			Chill_Sphere.Locked = true;

			Chill_Sphere.CFrame = H_R_P.CFrame;

			Chill_Sphere.E.Enabled = true;

			STT(Chill_Sphere,{Size = VT_3(30,30,30)},"Quad","Out",.5);

			STT(Chill_Sphere,{Transparency = 1},"Quad","Out",.5);

			STT(Chill_Sphere,{Orientation = VT_3(R1,R2,R3)},"Quad","Out",.5);

			wait(.5);

			game:GetService("Debris"):AddItem(Chill_Sphere, .01);

			Is_Rooted = false;
			Is_Attacking = false;
		end
	end
end

function Actions.SCREAM()
	if Chara then
		Is_Attacking = true;
		Is_Rooted = false;

		CS(C_H,"SFX",false,1,false,150,10,1252349760,0,6);

		for i = 0, 4.869, .1 do
			RSW();

			Attacking_NASP = .275;

			Animate(T_R,CF_N(0, 0, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
			Animate(L_S,CF_N(-1.5, 0.5, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(R_S,CF_N(1.5, 0.5, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
			Animate(L_H,CF_N(-0.5, -2, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(H_N,CF_N(0, 1.5, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(R_H,CF_N(0.5, -2, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
		end

		wait(.000001);

		Is_Rooted = false;
		Is_Attacking = false;
	end
end

function Actions.Look_At_My_Face(Position, Range)
	if Position and Range then
		for index, CD in pairs(game.Workspace:GetDescendants()) do
			if CD.ClassName == "Model" and CD ~= Chara then
				local MH = CD:FindFirstChildOfClass("Humanoid");

				if MH then				
					if not CD:FindFirstChild("HumanoidRootPart") and CD:FindFirstChild("Torso") then
						local MT = CD:FindFirstChild("Torso");

						if MT and Range >= (MT.Position - Position).Magnitude then
							Is_Attacking = true;
							Is_Rooted = true;

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							CS(C_H,"SFX",false,1,false,150,10,2581267360,0,6);

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.63, -4.21)*CF_A(M_R(130), M_R(0),M_R(-180)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, -0.85, -2.36)*CF_A(M_R(40), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, -0.85, -2.36)*CF_A(M_R(40), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -1.51, 0.53)*CF_A(M_R(-50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(H_N,CF_N(0, 1.59, 0.37)*CF_A(M_R(25), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(R_H,CF_N(0.5, -1.51, 0.53)*CF_A(M_R(-50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							wait(.5);

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, 0, -2.84)*CF_A(M_R(-135), M_R(0),M_R(-180)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 1.23, -0.11)*CF_A(M_R(135), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(R_S,CF_N(1.5, 1.23, -0.11)*CF_A(M_R(135), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -2.11, -0.83)*CF_A(M_R(45), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 	
							Animate(H_N,CF_N(0, 1.45, 0.11)*CF_A(M_R(45), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_H,CF_N(0.5, -2.11, -0.83)*CF_A(M_R(45), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							if C_H:FindFirstChild("Mesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0.875, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(3, 3, 3);
							elseif C_H:FindFirstChild("SpecialMesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0.875, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(3, 3, 3);
							end

							wait(.1);

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							AA("Normal",MT.Position, 7.75, 6,12,2,false);

							SCA({
								Intensity=25,
								Duration=.000000001, 
								Origin=MT.Position, 
								DropDist=1725, 
								IneffectiveDist=1950
							});

							local b = Instance.new("Part",Effects_Folder)
							b.Anchored = true
							b.CanCollide = true
							b.Size = Vector3.new(1,1,1)
							b.CFrame = MT.CFrame;
							b.BrickColor = BrickColor.new("White")
							b.Material = "Neon"
							b.Reflectance = 1

							local l = Instance.new("PointLight",b)
							l.Color = b.BrickColor.Color
							l.Brightness = 1
							l.Range = 0

							local bm = Instance.new("SpecialMesh",b)
							bm.Scale = Vector3.new(0,0,0)
							bm.MeshType = "Sphere"

							coroutine.wrap(function()
								for i=0,1,.1 do
									bm.Scale = Vector3.new(12.5*i,12.5*i,12.5*i);

									l.Range = 25*i;

									l.Brightness = 1-1*i;

									RSW();
								end

								b:Destroy();
							end)();

							for a=1,3 do
								local b = Instance.new("Part",Effects_Folder)
								b.Anchored = true
								b.CanCollide = true
								b.Size = Vector3.new(1,1,1)
								b.CFrame = MT.CFrame;
								b.BrickColor = BrickColor.new("White")
								b.Material = "Neon"

								local bm = Instance.new("SpecialMesh",b)
								bm.Scale = Vector3.new(0,0,0)
								bm.MeshType = "Sphere"

								b.CFrame = b.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))

								coroutine.wrap(function()
									for i=0,1,.1 do
										bm.Scale = Vector3.new(1.25*i,75*i,1.25*i);

										b.Transparency = i;

										RSW();
									end

									b:Destroy();
								end)()
							end

							wait(.4);

							if C_H:FindFirstChild("Mesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(1.25, 1.25, 1.25);
							elseif C_H:FindFirstChild("SpecialMesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(1.25, 1.25, 1.25);
							end

							Is_Rooted = false;
							Is_Attacking = false;
						end
					elseif CD:FindFirstChild("HumanoidRootPart") and not CD:FindFirstChild("UpperTorso") then
						local MT = CD:FindFirstChild("HumanoidRootPart");

						if MT and Range >= (MT.Position - Position).Magnitude then
							Is_Attacking = true;
							Is_Rooted = true;

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							CS(C_H,"SFX",false,1,false,150,10,2581267360,0,6);

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.63, -4.21)*CF_A(M_R(130), M_R(0),M_R(-180)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, -0.85, -2.36)*CF_A(M_R(40), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, -0.85, -2.36)*CF_A(M_R(40), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -1.51, 0.53)*CF_A(M_R(-50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(H_N,CF_N(0, 1.59, 0.37)*CF_A(M_R(25), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(R_H,CF_N(0.5, -1.51, 0.53)*CF_A(M_R(-50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							wait(.5);

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, 0, -2.84)*CF_A(M_R(-135), M_R(0),M_R(-180)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 1.23, -0.11)*CF_A(M_R(135), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(R_S,CF_N(1.5, 1.23, -0.11)*CF_A(M_R(135), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -2.11, -0.83)*CF_A(M_R(45), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 	
							Animate(H_N,CF_N(0, 1.45, 0.11)*CF_A(M_R(45), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_H,CF_N(0.5, -2.11, -0.83)*CF_A(M_R(45), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							if C_H:FindFirstChild("Mesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0.875, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(3, 3, 3);
							elseif C_H:FindFirstChild("SpecialMesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0.875, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(3, 3, 3);
							end

							wait(.1);

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							AA("Normal",MT.Position, 7.75, 6,12,2,false);

							SCA({
								Intensity=25,
								Duration=.000000001, 
								Origin=MT.Position, 
								DropDist=1725, 
								IneffectiveDist=1950
							});

							local b = Instance.new("Part",Effects_Folder)
							b.Anchored = true
							b.CanCollide = true
							b.Size = Vector3.new(1,1,1)
							b.CFrame = MT.CFrame;
							b.BrickColor = BrickColor.new("White")
							b.Material = "Neon"
							b.Reflectance = 1

							local l = Instance.new("PointLight",b)
							l.Color = b.BrickColor.Color
							l.Brightness = 1
							l.Range = 0

							local bm = Instance.new("SpecialMesh",b)
							bm.Scale = Vector3.new(0,0,0)
							bm.MeshType = "Sphere"

							coroutine.wrap(function()
								for i=0,1,.1 do
									bm.Scale = Vector3.new(12.5*i,12.5*i,12.5*i);

									l.Range = 25*i;

									l.Brightness = 1-1*i;

									RSW();
								end

								b:Destroy();
							end)();

							for a=1,3 do
								local b = Instance.new("Part",Effects_Folder)
								b.Anchored = true
								b.CanCollide = true
								b.Size = Vector3.new(1,1,1)
								b.CFrame = MT.CFrame;
								b.BrickColor = BrickColor.new("White")
								b.Material = "Neon"

								local bm = Instance.new("SpecialMesh",b)
								bm.Scale = Vector3.new(0,0,0)
								bm.MeshType = "Sphere"

								b.CFrame = b.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))

								coroutine.wrap(function()
									for i=0,1,.1 do
										bm.Scale = Vector3.new(1.25*i,75*i,1.25*i);

										b.Transparency = i;

										RSW();
									end

									b:Destroy();
								end)()
							end

							wait(.4);

							if C_H:FindFirstChild("Mesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(1.25, 1.25, 1.25);
							elseif C_H:FindFirstChild("SpecialMesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(1.25, 1.25, 1.25);
							end

							Is_Rooted = false;
							Is_Attacking = false;
						end
					elseif CD:FindFirstChild("HumanoidRootPart") and CD:FindFirstChild("UpperTorso") then
						local MT = CD:FindFirstChild("HumanoidRootPart");

						if MT and Range >= (MT.Position - Position).Magnitude then
							Is_Attacking = true;
							Is_Rooted = true;

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							CS(C_H,"SFX",false,1,false,150,10,2581267360,0,6);

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.63, -4.21)*CF_A(M_R(130), M_R(0),M_R(-180)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, -0.85, -2.36)*CF_A(M_R(40), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, -0.85, -2.36)*CF_A(M_R(40), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -1.51, 0.53)*CF_A(M_R(-50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(H_N,CF_N(0, 1.59, 0.37)*CF_A(M_R(25), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(R_H,CF_N(0.5, -1.51, 0.53)*CF_A(M_R(-50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							wait(.5);

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, 0, -2.84)*CF_A(M_R(-135), M_R(0),M_R(-180)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 1.23, -0.11)*CF_A(M_R(135), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(R_S,CF_N(1.5, 1.23, -0.11)*CF_A(M_R(135), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -2.11, -0.83)*CF_A(M_R(45), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 	
							Animate(H_N,CF_N(0, 1.45, 0.11)*CF_A(M_R(45), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_H,CF_N(0.5, -2.11, -0.83)*CF_A(M_R(45), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							if C_H:FindFirstChild("Mesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0.875, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(3, 3, 3);
							elseif C_H:FindFirstChild("SpecialMesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0.875, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(3, 3, 3);
							end

							wait(.1);

							MT.Anchored = true;

							H_R_P.CFrame = MT.CFrame;

							AA("Normal",MT.Position, 7.75, 6,12,2,false);

							SCA({
								Intensity=25,
								Duration=.000000001, 
								Origin=MT.Position, 
								DropDist=1725, 
								IneffectiveDist=1950
							});

							local b = Instance.new("Part",Effects_Folder)
							b.Anchored = true
							b.CanCollide = true
							b.Size = Vector3.new(1,1,1)
							b.CFrame = MT.CFrame;
							b.BrickColor = BrickColor.new("White")
							b.Material = "Neon"
							b.Reflectance = 1

							local l = Instance.new("PointLight",b)
							l.Color = b.BrickColor.Color
							l.Brightness = 1
							l.Range = 0

							local bm = Instance.new("SpecialMesh",b)
							bm.Scale = Vector3.new(0,0,0)
							bm.MeshType = "Sphere"

							coroutine.wrap(function()
								for i=0,1,.1 do
									bm.Scale = Vector3.new(12.5*i,12.5*i,12.5*i);

									l.Range = 25*i;

									l.Brightness = 1-1*i;

									RSW();
								end

								b:Destroy();
							end)();

							for a=1,3 do
								local b = Instance.new("Part",Effects_Folder)
								b.Anchored = true
								b.CanCollide = true
								b.Size = Vector3.new(1,1,1)
								b.CFrame = MT.CFrame;
								b.BrickColor = BrickColor.new("White")
								b.Material = "Neon"

								local bm = Instance.new("SpecialMesh",b)
								bm.Scale = Vector3.new(0,0,0)
								bm.MeshType = "Sphere"

								b.CFrame = b.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))

								coroutine.wrap(function()
									for i=0,1,.1 do
										bm.Scale = Vector3.new(1.25*i,75*i,1.25*i);

										b.Transparency = i;

										RSW();
									end

									b:Destroy();
								end)()
							end

							wait(.4);

							if C_H:FindFirstChild("Mesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(1.25, 1.25, 1.25);
							elseif C_H:FindFirstChild("SpecialMesh") then
								C_H:FindFirstChild("Mesh").Offset = VT_3(0, 0, 0);

								C_H:FindFirstChild("Mesh").Scale = VT_3(1.25, 1.25, 1.25);
							end

							Is_Rooted = false;
							Is_Attacking = false;
						end
					end
				end
			end
		end
	end
end

function Actions.Chill_Grab(Position, Range)
	if Position and Range then
		for index, CD in pairs(game.Workspace:GetDescendants()) do
			if CD.ClassName == "Model" and CD ~= Chara then
				local MH = CD:FindFirstChildOfClass("Humanoid");

				if MH then				
					if not CD:FindFirstChild("HumanoidRootPart") and CD:FindFirstChild("Torso") then
						local MT = CD:FindFirstChild("Torso");

						if MT and Range >= (MT.Position - Position).Magnitude then
							Is_Attacking = true;
							Is_Rooted = true;

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.6, -0.65)*CF_A(M_R(-65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -2.25, -0.54)*CF_A(M_R(10), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(H_N,CF_N(0, 1.45, 0.36)*CF_A(M_R(50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_H,CF_N(0.5, -1.4, -0.9)*CF_A(M_R(65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							wait(.1);

							local H_L = Joint("Handle_Weld",R_A,MT,CF_N(),CF_N());

							CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,6.25);

							wait(.15);

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.65, 1.05)*CF_A(M_R(50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 0.74, 0.36)*CF_A(M_R(-140), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, 0.7, 0.33)*CF_A(M_R(-140), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -1.29, 0.79)*CF_A(M_R(-85), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(H_N,CF_N(0, 1.55, 0.17)*CF_A(M_R(15), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(R_H,CF_N(0.5, -1.98, 0.21)*CF_A(M_R(-50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							wait(.1);

							repeat
								wait();
							until P_GM_Key_Hold == false;

							CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968224,0,6.25);

							wait(.25);

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.6, -0.65)*CF_A(M_R(-65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -2.25, -0.54)*CF_A(M_R(10), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(H_N,CF_N(0, 1.45, 0.36)*CF_A(M_R(50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_H,CF_N(0.5, -1.4, -0.9)*CF_A(M_R(65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							TO(Mousa.Hit.p);

							H_L:Destroy();

							wait(.00001);

							STT(MT,{CFrame = CF_N(Mousa.Hit.Position)},"Quad","Out",.425);

							CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,6.25);

							wait(.425);

							AA("Normal",MT.Position, 8.5, 5,8,2,false);

							SCA({
								Intensity=20,
								Duration=.000000001, 
								Origin=MT.Position, 
								DropDist=1725, 
								IneffectiveDist=1950
							});

							local b = Instance.new("Part",Effects_Folder)
							b.Anchored = true
							b.CanCollide = true
							b.Size = Vector3.new(1,1,1)
							b.CFrame = MT.CFrame;
							b.BrickColor = BrickColor.new("White")
							b.Material = "Neon"
							b.Reflectance = 1

							local l = Instance.new("PointLight",b)
							l.Color = b.BrickColor.Color
							l.Brightness = 1
							l.Range = 0

							local bm = Instance.new("SpecialMesh",b)
							bm.Scale = Vector3.new(0,0,0)
							bm.MeshType = "Sphere"

							local b2 = Meshes.Shockwave:Clone();
							b2.Parent = Effects_Folder;
							b2.Anchored = true
							b2.CanCollide = true
							b2.Size = Vector3.new(1,1,1)
							b2.CFrame = MT.CFrame;
							b2.BrickColor = BrickColor.new("White")
							b2.Material = "Neon"
							b2.Transparency = .25;

							b2.CFrame = b2.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))

							coroutine.wrap(function()
								for i=0,1,.1 do
									bm.Scale = Vector3.new(20*i,20*i,20*i);

									b2.Size = Vector3.new(32.5*i,1.5*i,37.5*i);

									b.Transparency = i;

									b2.Transparency = i;

									l.Range = 25*i;

									l.Brightness = 1-1*i;

									RSW();
								end

								b:Destroy();

								b2:Destroy();
							end)();

							for a=1,3 do
								local b = Instance.new("Part",Effects_Folder)
								b.Anchored = true
								b.CanCollide = true
								b.Size = Vector3.new(1,1,1)
								b.CFrame = MT.CFrame;
								b.BrickColor = BrickColor.new("White")
								b.Material = "Neon"

								local bm = Instance.new("SpecialMesh",b)
								bm.Scale = Vector3.new(0,0,0)
								bm.MeshType = "Sphere"

								b.CFrame = b.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))

								coroutine.wrap(function()
									for i=0,1,.1 do
										bm.Scale = Vector3.new(1.5*i,105*i,1.5*i);

										b.Transparency = i;

										RSW();
									end

									b:Destroy();
								end)()
							end

							wait(.5);

							Is_Rooted = false;
							Is_Attacking = false;
						end
					elseif CD:FindFirstChild("HumanoidRootPart") and not CD:FindFirstChild("UpperTorso") then
						local MT = CD:FindFirstChild("HumanoidRootPart");

						if MT and Range >= (MT.Position - Position).Magnitude then
							Is_Attacking = true;
							Is_Rooted = true;

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.6, -0.65)*CF_A(M_R(-65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -2.25, -0.54)*CF_A(M_R(10), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(H_N,CF_N(0, 1.45, 0.36)*CF_A(M_R(50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_H,CF_N(0.5, -1.4, -0.9)*CF_A(M_R(65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							wait(.1);

							local H_L = Joint("Handle_Weld",R_A,MT,CF_N(),CF_N());

							CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,6.25);

							wait(.15);

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.65, 1.05)*CF_A(M_R(50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 0.74, 0.36)*CF_A(M_R(-140), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, 0.7, 0.33)*CF_A(M_R(-140), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -1.29, 0.79)*CF_A(M_R(-85), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(H_N,CF_N(0, 1.55, 0.17)*CF_A(M_R(15), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(R_H,CF_N(0.5, -1.98, 0.21)*CF_A(M_R(-50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							wait(.1);

							repeat
								wait();
							until P_GM_Key_Hold == false;

							CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968224,0,6.25);

							wait(.25);

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.6, -0.65)*CF_A(M_R(-65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -2.25, -0.54)*CF_A(M_R(10), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(H_N,CF_N(0, 1.45, 0.36)*CF_A(M_R(50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_H,CF_N(0.5, -1.4, -0.9)*CF_A(M_R(65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							TO(Mousa.Hit.p);

							H_L:Destroy();

							wait(.00001);

							STT(MT,{CFrame = CF_N(Mousa.Hit.Position)},"Quad","Out",.425);

							CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,6.25);

							wait(.425);

							AA("Normal",MT.Position, 8.5, 5,8,2,false);

							SCA({
								Intensity=20,
								Duration=.000000001, 
								Origin=MT.Position, 
								DropDist=1725, 
								IneffectiveDist=1950
							});

							local b = Instance.new("Part",Effects_Folder)
							b.Anchored = true
							b.CanCollide = true
							b.Size = Vector3.new(1,1,1)
							b.CFrame = MT.CFrame;
							b.BrickColor = BrickColor.new("White")
							b.Material = "Neon"
							b.Reflectance = 1

							local l = Instance.new("PointLight",b)
							l.Color = b.BrickColor.Color
							l.Brightness = 1
							l.Range = 0

							local bm = Instance.new("SpecialMesh",b)
							bm.Scale = Vector3.new(0,0,0)
							bm.MeshType = "Sphere"

							local b2 = Meshes.Shockwave:Clone();
							b2.Parent = Effects_Folder;
							b2.Anchored = true
							b2.CanCollide = true
							b2.Size = Vector3.new(1,1,1)
							b2.CFrame = MT.CFrame;
							b2.BrickColor = BrickColor.new("White")
							b2.Material = "Neon"
							b2.Transparency = .25;

							b2.CFrame = b2.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))

							coroutine.wrap(function()
								for i=0,1,.1 do
									bm.Scale = Vector3.new(20*i,20*i,20*i);

									b2.Size = Vector3.new(32.5*i,1.5*i,37.5*i);

									b.Transparency = i;

									b2.Transparency = i;

									l.Range = 25*i;

									l.Brightness = 1-1*i;

									RSW();
								end

								b:Destroy();

								b2:Destroy();
							end)();

							for a=1,3 do
								local b = Instance.new("Part",Effects_Folder)
								b.Anchored = true
								b.CanCollide = true
								b.Size = Vector3.new(1,1,1)
								b.CFrame = MT.CFrame;
								b.BrickColor = BrickColor.new("White")
								b.Material = "Neon"

								local bm = Instance.new("SpecialMesh",b)
								bm.Scale = Vector3.new(0,0,0)
								bm.MeshType = "Sphere"

								b.CFrame = b.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))

								coroutine.wrap(function()
									for i=0,1,.1 do
										bm.Scale = Vector3.new(1.5*i,105*i,1.5*i);

										b.Transparency = i;

										RSW();
									end

									b:Destroy();
								end)()
							end

							wait(.5);

							Is_Rooted = false;
							Is_Attacking = false;
						end
					elseif CD:FindFirstChild("HumanoidRootPart") and CD:FindFirstChild("UpperTorso") then
						local MT = CD:FindFirstChild("HumanoidRootPart");

						if MT and Range >= (MT.Position - Position).Magnitude then
							Is_Attacking = true;
							Is_Rooted = true;

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.6, -0.65)*CF_A(M_R(-65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -2.25, -0.54)*CF_A(M_R(10), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(H_N,CF_N(0, 1.45, 0.36)*CF_A(M_R(50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_H,CF_N(0.5, -1.4, -0.9)*CF_A(M_R(65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							wait(.1);

							local H_L = Joint("Handle_Weld",R_A,MT,CF_N(),CF_N());

							CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,6.25);

							wait(.15);

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.65, 1.05)*CF_A(M_R(50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 0.74, 0.36)*CF_A(M_R(-140), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, 0.7, 0.33)*CF_A(M_R(-140), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -1.29, 0.79)*CF_A(M_R(-85), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(H_N,CF_N(0, 1.55, 0.17)*CF_A(M_R(15), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(R_H,CF_N(0.5, -1.98, 0.21)*CF_A(M_R(-50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							wait(.1);

							repeat
								wait();
							until P_GM_Key_Hold == false;

							CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968224,0,6.25);

							wait(.25);

							Attacking_NASP = .1;

							Animate(T_R,CF_N(0, -0.6, -0.65)*CF_A(M_R(-65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_S,CF_N(-1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_S,CF_N(1.5, 0.79, -0.43)*CF_A(M_R(155), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(L_H,CF_N(-0.5, -2.25, -0.54)*CF_A(M_R(10), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
							Animate(H_N,CF_N(0, 1.45, 0.36)*CF_A(M_R(50), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
							Animate(R_H,CF_N(0.5, -1.4, -0.9)*CF_A(M_R(65), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)

							TO(Mousa.Hit.p);

							H_L:Destroy();

							wait(.00001);

							STT(MT,{CFrame = CF_N(Mousa.Hit.Position)},"Quad","Out",.425);

							CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,6.25);

							wait(.425);

							AA("Normal",MT.Position, 8.5, 5,8,2,false);

							SCA({
								Intensity=20,
								Duration=.000000001, 
								Origin=MT.Position, 
								DropDist=1725, 
								IneffectiveDist=1950
							});

							local b = Instance.new("Part",Effects_Folder)
							b.Anchored = true
							b.CanCollide = true
							b.Size = Vector3.new(1,1,1)
							b.CFrame = MT.CFrame;
							b.BrickColor = BrickColor.new("White")
							b.Material = "Neon"
							b.Reflectance = 1

							local l = Instance.new("PointLight",b)
							l.Color = b.BrickColor.Color
							l.Brightness = 1
							l.Range = 0

							local bm = Instance.new("SpecialMesh",b)
							bm.Scale = Vector3.new(0,0,0)
							bm.MeshType = "Sphere"

							local b2 = Meshes.Shockwave:Clone();
							b2.Parent = Effects_Folder;
							b2.Anchored = true
							b2.CanCollide = true
							b2.Size = Vector3.new(1,1,1)
							b2.CFrame = MT.CFrame;
							b2.BrickColor = BrickColor.new("White")
							b2.Material = "Neon"
							b2.Transparency = .25;

							b2.CFrame = b2.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))

							coroutine.wrap(function()
								for i=0,1,.1 do
									bm.Scale = Vector3.new(20*i,20*i,20*i);

									b2.Size = Vector3.new(32.5*i,1.5*i,37.5*i);

									b.Transparency = i;

									b2.Transparency = i;

									l.Range = 25*i;

									l.Brightness = 1-1*i;

									RSW();
								end

								b:Destroy();

								b2:Destroy();
							end)();

							for a=1,3 do
								local b = Instance.new("Part",Effects_Folder)
								b.Anchored = true01
								b.CanCollide = true
								b.Size = Vector3.new(1,1,1)
								b.CFrame = MT.CFrame;
								b.BrickColor = BrickColor.new("White")
								b.Material = "Neon"

								local bm = Instance.new("SpecialMesh",b)
								bm.Scale = Vector3.new(0,0,0)
								bm.MeshType = "Sphere"

								b.CFrame = b.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))

								coroutine.wrap(function()
									for i=0,1,.1 do
										bm.Scale = Vector3.new(1.5*i,105*i,1.5*i);

										b.Transparency = i;

										RSW();
									end

									b:Destroy();
								end)()
							end

							wait(.5);

							Is_Rooted = false;
							Is_Attacking = false;
						end
					end
				end
			end
		end
	end
end

function Actions.Chill_Blast()
	Is_Attacking = true;
	Is_Rooted = true;

	CS(R_A,"SFX",false,.55,false,150,10,137463716,0,5.5);

	local ChillnessC = Meshes.Chillness2:Clone();

	local Chillness = ChillnessC:Clone();

	Chillness.Parent = Effects_Folder;

	Chillness.PrimaryPart.CFrame = R_A.CFrame;

	Chillness.PrimaryPart.Anchored = false;

	local H_L = Joint("Weld",R_A,Chillness.Main,CF_N(),CF_N());

	Chillness.Chillness.Transparency = 0;

	for i = 0, 10, .1 do
		RSW();

		TO(Mousa.Hit.p);

		Attacking_NASP = .275;

		local r1 = math.random(-1,1);

		local r2 = math.random(-1,1);

		local r3 = math.random(-1,1);

		Chillness.Chillness.a.C:Emit(1);

		Animate(T_R,CF_N(0, 1.6, 0)*CF_N(r1,r2,r3)*CF_A(M_R(5), M_R(0),M_R(0)),Attacking_NASP,"Lerp"); 
		Animate(L_S,CF_N(-1.39, 0.79, 0)*CF_A(M_R(0), M_R(0),M_R(-55)),Attacking_NASP,"Lerp");
		Animate(R_S,CF_N(1.72, 0.82, 0.11)*CF_A(M_R(165.1), M_R(-3.4),M_R(9.5)),Attacking_NASP,"Lerp");
		Animate(L_H,CF_N(-0.8, -2, 0)*CF_A(M_R(0), M_R(0),M_R(-15)),Attacking_NASP,"Lerp");
		Animate(H_N,CF_N(0, 1.33, 0.32)*CF_A(M_R(45), M_R(0),M_R(0)),Attacking_NASP,"Lerp");
		Animate(R_H,CF_N(0.8, -2, 0)*CF_A(M_R(0), M_R(0),M_R(15)),Attacking_NASP,"Lerp"); 

		TO(Mousa.Hit.p);
	end

	wait(.00001);

	for i = 0, 6.75, .1 do
		RSW();

		TO(Mousa.Hit.p);

		Attacking_NASP = .275;

		local r1 = math.random(-1,1);

		local r2 = math.random(-1,1);

		local r3 = math.random(-1,1);

		Chillness.Chillness.a.C:Emit(1);

		Animate(T_R,CF_N(0, 1.6, 0)*CF_N(r1,r2,r3)*CF_A(M_R(-26.1), M_R(39),M_R(11.3)),Attacking_NASP,"Lerp");
		Animate(L_S,CF_N(-1.7, 0.67, -0.02)*CF_A(M_R(-15.3), M_R(-6.3),M_R(-37.1)),Attacking_NASP,"Lerp");
		Animate(R_S,CF_N(1.68, 0.2, -0.48)*CF_A(M_R(126.2), M_R(-22.6),M_R(32.6)),Attacking_NASP,"Lerp");
		Animate(L_H,CF_N(-0.61, -2.08, -0.39)*CF_A(M_R(14.5), M_R(1.2),M_R(-3.3)),Attacking_NASP,"Lerp");
		Animate(H_N,CF_N(0.04, 1.49, -0.02)*CF_A(M_R(16.6), M_R(-35.1),M_R(-10.4)),Attacking_NASP,"Lerp");
		Animate(R_H,CF_N(0.7, -2, -0.35)*CF_A(M_R(14.5), M_R(1.2),M_R(8.8)),Attacking_NASP,"Lerp");

		TO(Mousa.Hit.p);
	end

	wait(.00001);

	Is_Rooted = false;
	Is_Attacking = false;

	Chillness.Chillness.Transparency = 1;

	local R1 = math.random(-5,5)

	NE({
		ET = "Shockwave",
		ES = VT_3(0,0,0),
		EES = VT_3(37.5, 0.1, 42.5),
		EST = .45,
		EET = 1,
		ECF = Chillness.Chillness.CFrame,
		EMD = nil,
		ER1 = 0,
		ER2 = R1,
		ER3 = 0,
		EM = "Neon",
		EC = CR_F_RGB(248, 248, 248),
		ETI = 40,
		ESID = nil,
		ESP = nil,
		ESV = nil,
		EUBRM = nil,
		EBR = 0,
		ESBR = 0
	})

	local R2 = math.random(-5,5)

	NE({
		ET = "Shockwave",
		ES = VT_3(0,0,0),
		EES = VT_3(11, 2.5, 13),
		EST = .45,
		EET = 1,
		ECF = Chillness.Chillness.CFrame,
		EMD = nil,
		ER1 = 0,
		ER2 = R2,
		ER3 = 0,
		EM = "Neon",
		EC = CR_F_RGB(248, 248, 248),
		ETI = 40,
		ESID = nil,
		ESP = nil,
		ESV = nil,
		EUBRM = nil,
		EBR = 0,
		ESBR = 0
	})

	local Chillness2C = Meshes.Chillness:Clone();

	local Chillness2 = Chillness2C:Clone();

	Chillness2.Attachment_.F.Enabled = true;

	Chillness2.Parent = Effects_Folder;

	Chillness2.CFrame = Chillness.Chillness.CFrame;

	wait(.125);

	if Chillness2 then
		RSW();

		STT(Chillness2,{CFrame = CF_N(Mousa.Hit.Position)},"Quad","Out",.45);

		wait(.45);

		local Chill_SphereC = Meshes.Chill_Sphere:Clone();

		local Chill_Sphere = Chill_SphereC:Clone();

		Chill_Sphere.Parent = Effects_Folder;

		Chill_Sphere.Size = VT_3(10, 10, 10);

		Chill_Sphere.Transparency = 0;

		Chill_Sphere.Anchored = true;

		Chill_Sphere.Locked = true;

		Chill_Sphere.CFrame = Chillness2.CFrame;

		AA("Normal",Chillness2.Position, 15, 5,15,2,false);

		CS(C_H,"SFX",false,M_RAN(.9,1),false,150,10,2834968945,0,6.25);

		SCA({
			Intensity=30,
			Duration=.000000001, 
			Origin=Chill_Sphere.Position, 
			DropDist=1725, 
			IneffectiveDist=1950
		});

		game:GetService("Debris"):AddItem(Chillness2, .01);

		if Chill_Sphere then
			Chill_Sphere.a.E:Emit(1500);

			local R1 = math.random(-5,5);

			local R2 = math.random(-5,5);

			local R3 = math.random(-5,5);

			STT(Chill_Sphere,{Size = VT_3(52.5,52.5,52.5)},"Quad","Out",2.5);

			STT(Chill_Sphere,{Transparency = 1},"Quad","Out",2.5);

			STT(Chill_Sphere,{Orientation = VT_3(R1,R2,R3)},"Quad","Out",2.5);

			wait(2.5);

			Chill_Sphere.a.E.Enabled = false;

			wait(2.5);

			Chill_Sphere:Destroy();

			H_L:Destroy();

			Chillness:Destroy();

			wait(.00001);
		end
	end
end

function Actions.Chill_Attack()
	local Target_Mousa = Mousa.Target.Parent;

	if Target_Mousa then
		if Target_Mousa:FindFirstChild("HumanoidRootPart") then
			Is_Attacking = true;
			Is_Rooted = true;

			local Posa = Target_Mousa:FindFirstChild("HumanoidRootPart");

			wait(.00001);

			H_R_P.CFrame = Posa.CFrame * CF_N(0,0,1);

			wait(.00001);

			Attacking_NASP = .15;

			Animate(T_R,CF_N(-0.1, -0.3, 0.6)*CF_A(M_R(42.9), M_R(-14),M_R(7.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_S,CF_N(-1.63, 0.42, -0.14)*CF_A(M_R(80.8), M_R(1),M_R(2.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(R_S,CF_N(1.48, 0.41, -0.15)*CF_A(M_R(-34.7), M_R(-1.9),M_R(6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_H,CF_N(-0.4, -1.87, 0.4)*CF_A(M_R(-49.6), M_R(9.8),M_R(6.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(H_N,CF_N(-0.03, 1.5, -0.14)*CF_A(M_R(-27.4), M_R(12.3),M_R(18.4)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_H,CF_N(0.68, -1.53, 0.73)*CF_A(M_R(-61.4), M_R(-7.4),M_R(7.9)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 

			wait(.25);

			Attacking_NASP = .1;

			Animate(T_R,CF_N(-0.1, -0.3, -0.1)*CF_A(M_R(-49.8), M_R(-3.6),M_R(-2.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_S,CF_N(-1.13, 1.14, -0.76)*CF_A(M_R(121.3), M_R(-23.4),M_R(32.1)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_S,CF_N(1.48, 0.41, -0.15)*CF_A(M_R(-34.7), M_R(-1.9),M_R(6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_H,CF_N(-0.54, -1.23, -1.29)*CF_A(M_R(57.2), M_R(10.5),M_R(-4)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(H_N,CF_N(-0.12, 1.54, 0.12)*CF_A(M_R(19.7), M_R(6.9),M_R(-0.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_H,CF_N(0.63, -1.94, -0.38)*CF_A(M_R(-1.8), M_R(-3.3),M_R(6.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);

			wait(.15);

			CS(L_A,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,5.5);

			AA("Flash",L_A.Position,8.25,8,15,0,false);

			Is_Rooted = false;
			Is_Attacking = false;
		elseif not Target_Mousa:FindFirstChild("HumanoidRootPart") and Target_Mousa:FindFirstChild("Torso") then
			Is_Attacking = true;
			Is_Rooted = true;

			local Posa = Target_Mousa:FindFirstChild("Torso");

			wait(.00001);

			H_R_P.CFrame = Posa.CFrame * CF_N(0,0,1);

			wait(.00001);

			Attacking_NASP = .15;

			Animate(T_R,CF_N(-0.1, -0.3, 0.6)*CF_A(M_R(42.9), M_R(-14),M_R(7.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_S,CF_N(-1.63, 0.42, -0.14)*CF_A(M_R(80.8), M_R(1),M_R(2.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(R_S,CF_N(1.48, 0.41, -0.15)*CF_A(M_R(-34.7), M_R(-1.9),M_R(6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_H,CF_N(-0.4, -1.87, 0.4)*CF_A(M_R(-49.6), M_R(9.8),M_R(6.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 
			Animate(H_N,CF_N(-0.03, 1.5, -0.14)*CF_A(M_R(-27.4), M_R(12.3),M_R(18.4)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_H,CF_N(0.68, -1.53, 0.73)*CF_A(M_R(-61.4), M_R(-7.4),M_R(7.9)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out); 

			wait(.25);

			Attacking_NASP = .1;

			Animate(T_R,CF_N(-0.1, -0.3, -0.1)*CF_A(M_R(-49.8), M_R(-3.6),M_R(-2.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_S,CF_N(-1.13, 1.14, -0.76)*CF_A(M_R(121.3), M_R(-23.4),M_R(32.1)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_S,CF_N(1.48, 0.41, -0.15)*CF_A(M_R(-34.7), M_R(-1.9),M_R(6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(L_H,CF_N(-0.54, -1.23, -1.29)*CF_A(M_R(57.2), M_R(10.5),M_R(-4)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(H_N,CF_N(-0.12, 1.54, 0.12)*CF_A(M_R(19.7), M_R(6.9),M_R(-0.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);
			Animate(R_H,CF_N(0.63, -1.94, -0.38)*CF_A(M_R(-1.8), M_R(-3.3),M_R(6.2)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out);

			wait(.15);

			CS(L_A,"SFX",false,M_RAN(.9,1),false,150,10,2834968597,0,5.5);

			AA("Flash",L_A.Position,8.25,8,15,0,false);

			Is_Rooted = false;
			Is_Attacking = false;
		end
	end
end

function Actions.Reset()
	Is_Attacking = true;
	Is_Rooted = false;

	for i = 0, 4.869, .1 do
		RSW();

		Attacking_NASP = .275;

		Animate(T_R,CF_N(0, 0, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
		Animate(L_S,CF_N(-1.5, 0.5, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
		Animate(R_S,CF_N(1.5, 0.5, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out) 
		Animate(L_H,CF_N(-0.5, -2, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
		Animate(H_N,CF_N(0, 1.5, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
		Animate(R_H,CF_N(0.5, -2, 0)*CF_N(math.random(-2.25,2.25), math.random(-2.25,2.25), math.random(-2.25,2.25))*CF_A(M_R(0), M_R(0),M_R(0))*CF_A(M_R(math.random(-360,360)), M_R(math.random(-360,360)),M_R(math.random(-360,360))),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
	end

	wait(0.5);

	H:Destroy()
	C_H:Destroy()
	C_T:Destroy()
	H_R_P:Destroy()
	R_A:Destroy()
	R_L:Destroy()
	L_A:Destroy()
	L_L:Destroy()




	local R1 = math.random(-5,5);

	local R2 = math.random(-5,5);

	local R3 = math.random(-5,5);

	local Chill_Sphere = Meshes.Chill_Sphere2:Clone();

	Chill_Sphere.Parent = Effects_Folder;

	Chill_Sphere.Size = VT_3(5,5,5);

	Chill_Sphere.Transparency = .2;

	Chill_Sphere.Anchored = true;

	Chill_Sphere.Locked = true;

	Chill_Sphere.CFrame = H_R_P.CFrame;

	Chill_Sphere.E.Enabled = true;

	STT(Chill_Sphere,{Size = VT_3(30,30,30)},"Quad","Out",.5);

	STT(Chill_Sphere,{Transparency = 1},"Quad","Out",.5);

	STT(Chill_Sphere,{Orientation = VT_3(R1,R2,R3)},"Quad","Out",.5);

	wait(.5);

	game:GetService("Debris"):AddItem(Chill_Sphere, .01);

	wait(2)


	if Playa then
		if Playa.Character and Chara then
			Playa:LoadCharacter();
		end
	end

	Is_Rooted = false;
	Is_Attacking = false;
end


if Code:FindFirstChild("CUI") then
	local CUI_Clone = Code:FindFirstChild("CUI"):Clone()

	CUI_Clone.Parent = Playa.PlayerGui

	CUI_Clone.Enabled = true
end

function Actions.FixCUI()
	if Code:FindFirstChild("CUI") then
		if Playa.PlayerGui:FindFirstChild("CUI") then
			-- ok.
		elseif not Playa.PlayerGui:FindFirstChild("CUI") then
			if Code:FindFirstChild("CUI") then
				local CUI_Clone = Code:FindFirstChild("CUI"):Clone()

				CUI_Clone.Parent = Playa.PlayerGui

				CUI_Clone.Enabled = true
			end
		end
	end
end

function Actions.ToggleMusic()
	if MV == 1.5 then
		MV = 0;
	elseif MV == 0 then
		MV = 1.5;
	end
end

function P_GM_B1D(Mousa)
	P_GM_Hold = true;
	if Is_Attacking == false then
		if Combo == 1 then
			Combo = 2;

			Actions.Combos(Combo);
		elseif Combo == 2 then
			Combo = 1;

			Actions.Combos(Combo);
		end
	end
end

function P_GM_B1U(Mousa)
	P_GM_Hold = false;
end

function P_GM_K_D(P_GM_KeyCode)
	if P_GM_KeyCode == "k" then
		if CameraScript.Value.Value == C_H then
			CameraScript.Value.Value = H
		elseif CameraScript.Value.Value == H then
			CameraScript.Value.Value = C_H
		end
	elseif P_GM_KeyCode == "e"  and Is_Attacking == false then
		Actions.Teleport();
	elseif P_GM_KeyCode == "f"  and Is_Attacking == false then
		Actions.SCREAM();
	elseif P_GM_KeyCode == "z"  and Is_Attacking == false then
		Actions.Look_At_My_Face(H_R_P.Position, 7.5);
	elseif P_GM_KeyCode == "x"  and Is_Attacking == false then
		Actions.Chill_Grab(H_R_P.Position, 7.5);
	elseif P_GM_KeyCode == "c"  and Is_Attacking == false then
		Actions.Chill_Blast();
	elseif P_GM_KeyCode == "v"  and Is_Attacking == false then
		Actions.Chill_Attack();
	elseif P_GM_KeyCode == "l"  and Is_Attacking == false then
		Actions.Reset();
	elseif P_GM_KeyCode == "m" then
		P_GM_Key_Hold = true;

		Actions.ToggleMusic();
	end
end

function P_GM_K_U(P_GM_KeyCode)	
	if P_GM_KeyCode == "c" then
		P_GM_Key_Hold = false;
	end
end

Mousa.Button1Down:Connect(function(N_K)
	P_GM_B1D(N_K);
end)

Mousa.Button1Up:Connect(function(N_K)
	P_GM_B1U(N_K);
end)

Mousa.KeyDown:Connect(function(N_K)
	P_GM_K_D(N_K);
end)

Mousa.KeyUp:Connect(function(N_K)
	P_GM_K_U(N_K);
end)

local PFXsC = Meshes.PFXs:Clone();

local PFXs1C = PFXsC.Attachment_:Clone();

PFXs1C.Name = "Attachment_1";

PFXs1C.Parent = R_A;

local PFXs2C = PFXsC.Attachment_:Clone();

PFXs2C.Name = "Attachment_2";

PFXs2C.Parent = L_A;

local Numb = 360;

while true do
	RSW()
	if C_H:FindFirstChild("face") ~= nil then
		C_H.face.Texture = "rbxassetid://7074749";
	else
		local face = Instance.new("Decal",C_H);

		face.Face = Enum.NormalId.Front;

		face.Texture = "rbxassetid://7074749";
	end
	for _,hs in next, H:GetPlayingAnimationTracks() do
		hs:Stop()
	end
	if Is_Rooted == true then
		H_R_P.Anchored = true
	elseif Is_Rooted == false then
		H_R_P.Anchored = false
	end
	Anim_Sine = Anim_Sine + Anim_Change
	local TV = (H_R_P.Velocity * VT_3(1, 0, 1)).magnitude
	local TVV = H_R_P.Velocity.y
	local Hit,Pos = CPR2(H_R_P.Position,H_R_P.Position-VT_3(0,1,0),4)
	local Walking = H.MoveDirection.magnitude>0
	if Sprinting == false then
		Anim_Type = (not Hit and H_R_P.Velocity.Y<-1 or H.Sit and 'Sit' and 'Fall' or not Hit and H_R_P.Velocity.Y>1 and 'Jump' or Walking and "Walk" or "Idle")
	elseif Sprinting == true then
		Anim_Type = (not Hit and H_R_P.Velocity.Y<-1 or H.Sit and 'Sit' and 'Fall' or not Hit and H_R_P.Velocity.Y>1 and 'Jump' or Walking and "Run" or "Idle")
	end
	local WSV = 8 / (H.WalkSpeed / 16)
	local WSV2 = 8 / (H.WalkSpeed / 16)

	if TVV > 20 then
		TVV = 20
	elseif TVV < -20 then
		TVV = -20
	end

	--I know this looks like jl's
	--It's more inspired by my old one which is a modified ver of Kyu's, but replacing Root.Velocity with Hum.MoveDirection and removing the clamp

	FwdDir = (Walking and H.MoveDirection*H_R_P.CFrame.lookVector or VT_3())

	RigDir = (Walking and H.MoveDirection*H_R_P.CFrame.rightVector or VT_3())

	Vec = {
		X=RigDir.X+RigDir.Z,
		Z=FwdDir.X+FwdDir.Z
	};

	Divide = 1

	if(Vec.Z<0)then
		Divide=math.clamp(-(1.25),1,2)
	end

	Vec.Z = Vec.Z/Divide
	Vec.X = Vec.X/Divide

	sidevec = math.clamp((H_R_P.Velocity*H_R_P.CFrame.rightVector).X+(H_R_P.Velocity*H_R_P.CFrame.rightVector).Z,-H.WalkSpeed,H.WalkSpeed)
	sidevelocity = sidevec/H.WalkSpeed
	forwardvec =  math.clamp((H_R_P.Velocity*H_R_P.CFrame.lookVector).X+(H_R_P.Velocity*H_R_P.CFrame.lookVector).Z,-H.WalkSpeed,H.WalkSpeed)
	forwardvelocity = forwardvec/H.WalkSpeed

	if Sprinting == false then
		Sppedd = 48;
		H.JumpPower = 200;
		if Is_Attacking == false then
			H.WalkSpeed = Sppedd/Divide
			wsVal = 6 / (H.WalkSpeed / 48)
			WsFactor = wsVal
			movement = 6
		end
	elseif Sprinting == true then
		Sppedd = 48;
		H.JumpPower = 200;
		if Is_Attacking == false then
			H.WalkSpeed = Sppedd/Divide
			wsVal = 8 / (H.WalkSpeed / 48)
			WsFactor = wsVal
			movement = 8
		end
	end

	if Anim_Type == "Idle" then
		if Is_Attacking == false then
			NASP = .4
			Change = Anim_Change

			Animate(T_R,CF_N(0, 1.2 + .5 * M_C(Anim_Sine / 8), 0)*CF_A(M_R(0), M_R(0),M_R(0)),NASP,"Lerp")
			Animate(L_S,CF_N(-1.41, 0.56, 0.2)*CF_A(M_R(14.8 - 1 * M_S(Anim_Sine / 10)), M_R(31.4 + 1 * M_S(Anim_Sine / 10)),M_R(-26.5 + 1 * M_S(Anim_Sine / 10))),NASP,"Lerp") 
			Animate(R_S,CF_N(1.31, 0.56, 0.2)*CF_A(M_R(14.8 - 1 * M_S(Anim_Sine / 10)), M_R(-31.5 + 1 * M_S(Anim_Sine / 10)),M_R(26.5 - 1 * M_S(Anim_Sine / 10))),NASP,"Lerp") 
			Animate(L_H,CF_N(-0.5, -1.2, -0.7)*CF_A(M_R(-5 + 1.25 * M_S(Anim_Sine / 10)), M_R(0),M_R(0)),NASP,"Lerp")
			Animate(H_N,CF_N(0, 1.5, 0)*CF_A(M_R(-5 + 1.5 * M_S(Anim_Sine / 10)), M_R(0),M_R(0)),NASP,"Lerp")
			Animate(R_H,CF_N(0.5, -2, 0)*CF_A(M_R(-2.5 + 1.25 * M_S(Anim_Sine / 10)), M_R(0),M_R(0)),NASP,"Lerp")
		end
	elseif Anim_Type == "Walk" then
		if Is_Attacking == false then
			NASP = .25
			Change = Anim_Change

			--local RootJoint = Instance.new("Motor",RootPart)
			--RootJoint.Part0 = RootPart
			--RootJoint.Part1 = Torso
			--RootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			--RootJoint.C1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)

			--local LH = Instance.new("Motor",Torso)
			--LH.Part0 = Torso
			--LH.Part1 = LeftLeg
			--LH.C0 = CFrame.new(0,0,0)
			--LH.C1 = CFrame.new(0,1,0)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))

			--local RH = Instance.new("Motor",Torso)
			--RH.Part0 = Torso
			--RH.Part1 = RightLeg
			--RH.C0 = CFrame.new(0,0,0)
			--RH.C1 = CFrame.new(0,1,0)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))

			--local LS = Instance.new("Motor",Torso)
			--LS.Part0 = Torso
			--LS.Part1 = LeftArm
			--LS.C0 = CFrame.new(0,0,0)
			--LS.C1 = CFrame.new(0,0.5,0)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))

			--local RS = Instance.new("Motor",Torso)
			--RS.Part0 = Torso
			--RS.Part1 = RightArm
			--RS.C0 = CFrame.new(0,0,0)
			--RS.C1 = CFrame.new(-0,0.5,0)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))

			--local Neck = Instance.new("Motor",Torso)
			--Neck.Part0 = Torso
			--Neck.Part1 = Head
			--Neck.C0 = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			--Neck.C1 = CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)


			Alpha = .2

			--R_H.C0=R_H.C0:lerp(CFrame.new(.5,-2,0)*CFrame.new(0,0 + 1 * math.cos(Anim_Sine / 2.5),-0- 1.25 * math.sin(Anim_Sine / 5))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*CFrame.Angles(math.rad(-10+100 * math.sin(Anim_Sine / 5)),math.rad(0),math.rad(0)),Alpha)
			--L_H.C0=L_H.C0:lerp(CFrame.new(-.5,-2,0)*CFrame.new(-0,0 + 1 * math.cos(Anim_Sine / 2.5),0+ 1.25 * math.sin(Anim_Sine / 5))*CFrame.Angles(math.rad(0),math.rad(-0),math.rad(0))*CFrame.Angles(math.rad(-10-100 * math.sin(Anim_Sine / 5)),math.rad(0),math.rad(0)),Alpha)
			--T_R.C0=T_R.C0:lerp(CFrame.new(0,0,0)*CFrame.new(0,0 + 1 * math.cos(Anim_Sine / 2.5),0)*CFrame.Angles(math.rad(0+10  + 1 * math.cos(Anim_Sine / 5)),math.rad(0),math.rad(45 * math.sin(Anim_Sine / 5))),Alpha)
			--H_N.C0=H_N.C0:lerp(CFrame.new(0, 1.5,0)*CFrame.new(0, 0, 0)*CFrame.Angles(math.rad(0  + 2 * math.sin(Anim_Sine / 5)),math.rad(-12.5 * math.sin(Anim_Sine / 5)),math.rad(0)),Alpha)
			--R_S.C0=R_S.C0:lerp(CFrame.new(1.5,.5,0)*CFrame.new(0+0.5*math.sin(Anim_Sine/5),0,-1.5 * math.sin(Anim_Sine / 5))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))*CFrame.Angles(math.rad(60+40* math.sin(Anim_Sine / 5)),math.rad(0),math.rad(-45-115 * math.sin(Anim_Sine / 5))),Alpha)
			--L_S.C0=L_S.C0:lerp(CFrame.new(-1.5,.5,0)*CFrame.new(-0-0.5*math.sin(Anim_Sine/5),0, 1.5 * math.sin(Anim_Sine / 5))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))*CFrame.Angles(math.rad(60-40* math.sin(Anim_Sine / 5)),math.rad(0),math.rad(45-115 * math.sin(Anim_Sine / 5))),Alpha)

			Animate(T_R,CF_N(0, 0 + 1 * M_C(Anim_Sine / 2.5), 0)*CF_A(M_R(0 + 10 + 1 * M_C(Anim_Sine / 5)), M_R(45 * M_S(Anim_Sine / 5)),M_R(0 - 5 * M_C(Anim_Sine/7))),NASP,"Lerp") 
			Animate(L_S,CF_N(-1.5-0.5*M_S(Anim_Sine/5), 0.33,1.5 * M_S(Anim_Sine / 5))*CF_A(M_R(-60 + 40 * M_S(Anim_Sine/5)), M_R(0),M_R(-45+115 * M_S(Anim_Sine / 5))),NASP,"Lerp")
			Animate(R_S,CF_N(1.5-0.5*M_S(Anim_Sine/5), 0.33,-1.5 * M_S(Anim_Sine / 5))*CF_A(M_R(-60 - 40 * M_S(Anim_Sine/5)), M_R(0),M_R(45+115 * M_S(Anim_Sine / 5))),NASP,"Lerp") 
			Animate(L_H,CF_N(-0.525, -1.9, 0 - 2 * M_S(Anim_Sine/5))*CF_A(M_R(10 + 100 * M_S(Anim_Sine/5)), M_R(0),M_R(-2.5)),NASP,"Lerp") 
			Animate(H_N,CF_N(0, 1.5, 0)*CF_A(M_R(0 + 2 * M_S(Anim_Sine / 5)), M_R(-12.5 * M_S(Anim_Sine / 5)),M_R(0)),NASP,"Lerp")
			Animate(R_H,CF_N(0.525, -1.9, 0 + 2 * M_S(Anim_Sine/5))*CF_A(M_R(-10 - 100 * M_S(Anim_Sine/5)), M_R(0),M_R(-2.5)),NASP,"Lerp")
		end
	elseif Anim_Type == "Run" then
		if Is_Attacking == false then
			NASP = .4
			Change = Anim_Change

			Animate(T_R,CF_N(0, 0 + .105 * M_C(Anim_Sine/7), 0)*CF_A(M_R(2.5 + 1.25 * M_C(Anim_Sine/7)), M_R(0 - 45 * M_C(Anim_Sine/7)),M_R(0 - 5 * M_C(Anim_Sine/7))),NASP,"Lerp") 
			Animate(L_S,CF_N(-1.5, 0.33, 0 + 0.62 * M_C(Anim_Sine/7))*CF_A(M_R(0 - 75 * M_C(Anim_Sine/7)), M_R(0),M_R(0)),NASP,"Lerp")
			Animate(R_S,CF_N(1.5, 0.33, 0 - 0.62 * M_C(Anim_Sine/7))*CF_A(M_R(0 + 75 * M_C(Anim_Sine/7)), M_R(0),M_R(0)),NASP,"Lerp") 
			Animate(L_H,CF_N(-0.725, -1.9, 0 - 1.6 * M_C(Anim_Sine/7))*CF_A(M_R(0 + 74 * M_C(Anim_Sine/7)), M_R(0),M_R(-9)),NASP,"Lerp") 
			Animate(H_N,CF_N(0, 1.5, 0)*CF_A(M_R(0), M_R(0),M_R(0)),NASP,"Lerp")
			Animate(R_H,CF_N(0.725, -1.9, 0 + 1.6 * M_C(Anim_Sine/7))*CF_A(M_R(0 - 74 * M_C(Anim_Sine/7)), M_R(0),M_R(9)),NASP,"Lerp")
		end	
	elseif Anim_Type == "Jump" then
		if Is_Attacking == false then
			local Alpha = .2
			Change = Anim_Change

			Animate(T_R,CF_N(0, 0, 0)*CF_A(M_R(0 + 720 * M_S(Anim_Sine/10)), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(L_S,CF_N(-1.19, 0.88, -0.22)*CF_A(M_R(118.1), M_R(-23.2),M_R(45.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(R_S,CF_N(1.26, 0.88, -0.22)*CF_A(M_R(118.1), M_R(23.2),M_R(-45.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(L_H,CF_N(-0.5, -1.1, -0.28)*CF_A(M_R(-30), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(H_N,CF_N(0, 1.5, 0)*CF_A(M_R(-18), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(R_H,CF_N(0.5, -1.1, -0.28)*CF_A(M_R(-30), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
		end	
	elseif Anim_Type == "Fall" then
		if Is_Attacking == false then
			local Alpha = .2
			Change = Anim_Change

			Animate(T_R,CF_N(0, 0, 0)*CF_A(M_R(0 + 720 * M_S(Anim_Sine/10)), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(L_S,CF_N(-1.19, 0.88, -0.22)*CF_A(M_R(118.1), M_R(-23.2),M_R(45.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(R_S,CF_N(1.26, 0.88, -0.22)*CF_A(M_R(118.1), M_R(23.2),M_R(-45.6)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(L_H,CF_N(-0.5, -1.1, -0.28)*CF_A(M_R(-30), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(H_N,CF_N(0, 1.5, 0)*CF_A(M_R(-18), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
			Animate(R_H,CF_N(0.5, -1.1, -0.28)*CF_A(M_R(-30), M_R(0),M_R(0)),Attacking_NASP,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
		end	
	end

	Music_Effect.Parent = H_R_P
	Music_Effect.Name = "Music_Effect"
	Music_Effect.Looped = IL
	Music_Effect.PlaybackSpeed = PBSA
	Music_Effect.Playing = IPING
	Music_Effect.RollOffMaxDistance = ROMD
	Music_Effect.RollOffMinDistance = ROMMD
	Music_Effect.SoundId = "rbxassetid://"..MID
	Music_Effect.Volume = MV
	Music_Effect.SoundGroup = nil;

	if Music_Effect.Parent ~= H_R_P then
		print("Fixing music")

		Music_Effect = I_N("Sound", H_R_P)
		Music_Effect.Parent = H_R_P
		Music_Effect.Name = "Music_Effect"
		Music_Effect.Looped = IL
		Music_Effect.PlaybackSpeed = PBSA
		Music_Effect.Playing = IPING
		Music_Effect.dId = "rbxassetid://"..MID
		Music_Effect.Volume = MV
		Music_Effect.SoundGroup = nil;

		Repairing = true
	elseif Repairing == false then

	else
		Repairing = false
	end

	H_R_P.Transparency = 1
end
